<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>山外1: 函数式编程 | Edsyang</title><meta name="description" content="前言函数式以优雅、简单的特点开始重新风靡整个编程界, 主流语言在设计时会更多参考函数式特性, 前端领域也能看到很多函数式编程的影子: ES6 的箭头函数、Redux 引入 Elm 降低 Flux 的复杂性、React 16.8 之后的 Hooks 使得 pure functional components 成为可能 代码思维的演变 命令式编程 用传统的编程思维, 上来就撸代码, 但是会产生一对中间"><meta name="keywords" content="Personal blog about font-end technology &amp; record others"><meta name="author" content="Edsyang,1966861494@qq.com"><meta name="copyright" content="Edsyang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="山外1: 函数式编程"><meta name="twitter:description" content="前言函数式以优雅、简单的特点开始重新风靡整个编程界, 主流语言在设计时会更多参考函数式特性, 前端领域也能看到很多函数式编程的影子: ES6 的箭头函数、Redux 引入 Elm 降低 Flux 的复杂性、React 16.8 之后的 Hooks 使得 pure functional components 成为可能 代码思维的演变 命令式编程 用传统的编程思维, 上来就撸代码, 但是会产生一对中间"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="山外1: 函数式编程"><meta property="og:url" content="http://blog.lagerstroemia.com.cn/2020/04/13/js/mount/function/"><meta property="og:site_name" content="Edsyang"><meta property="og:description" content="前言函数式以优雅、简单的特点开始重新风靡整个编程界, 主流语言在设计时会更多参考函数式特性, 前端领域也能看到很多函数式编程的影子: ES6 的箭头函数、Redux 引入 Elm 降低 Flux 的复杂性、React 16.8 之后的 Hooks 使得 pure functional components 成为可能 代码思维的演变 命令式编程 用传统的编程思维, 上来就撸代码, 但是会产生一对中间"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2020-04-13T15:35:37.774Z"><meta property="article:modified_time" content="2020-05-03T03:09:19.607Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.lagerstroemia.com.cn/2020/04/13/js/mount/function/"><link rel="prev" title="Vue3 源码解析" href="http://blog.lagerstroemia.com.cn/2020/04/17/frame/vue/vue3/"><link rel="next" title="tsconfig 常用配置" href="http://blog.lagerstroemia.com.cn/2020/04/12/ts/tsconfig/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Edsyang","link":"链接: ","source":"来源: Edsyang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Edsyang" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">113</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">38</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码思维的演变"><span class="toc-number">2.</span> <span class="toc-text">代码思维的演变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么叫函数式编程"><span class="toc-number">3.</span> <span class="toc-text">为什么叫函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程的特点"><span class="toc-number">4.</span> <span class="toc-text">函数式编程的特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数是“一等公民”-First-Class-Functions"><span class="toc-number">4.1.</span> <span class="toc-text">函数是“一等公民” (First-Class Functions)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#声明式编程-Declarative-Programming"><span class="toc-number">4.2.</span> <span class="toc-text">声明式编程 (Declarative Programming)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#惰性执行（Lazy-Evaluation）"><span class="toc-number">4.3.</span> <span class="toc-text">惰性执行（Lazy Evaluation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#无状态和数据不可变-Statelessness-and-Immutable-data"><span class="toc-number">4.4.</span> <span class="toc-text">无状态和数据不可变 (Statelessness and Immutable data)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#没有副作用（No-Side-Effects）"><span class="toc-number">4.5.</span> <span class="toc-text">没有副作用（No Side Effects）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#纯函数-pure-functions"><span class="toc-number">4.6.</span> <span class="toc-text">纯函数 (pure functions)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#流水线的构建"><span class="toc-number">5.</span> <span class="toc-text">流水线的构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#加工站-函数柯里化-Currying"><span class="toc-number">5.1.</span> <span class="toc-text">加工站 - 函数柯里化 (Currying)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#部分函数应用-vs-柯里化"><span class="toc-number">5.1.1.</span> <span class="toc-text">部分函数应用 vs 柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#高级柯里化"><span class="toc-number">5.1.2.</span> <span class="toc-text">高级柯里化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#柯里化的应用"><span class="toc-number">5.1.3.</span> <span class="toc-text">柯里化的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流水线-函数组合-Compose"><span class="toc-number">5.2.</span> <span class="toc-text">流水线 - 函数组合 (Compose)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数组合应用"><span class="toc-number">5.2.1.</span> <span class="toc-text">函数组合应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数组合的好处"><span class="toc-number">5.2.2.</span> <span class="toc-text">函数组合的好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compose-gt-Pointfree-编程风格"><span class="toc-number">5.3.</span> <span class="toc-text">compose -&gt; Pointfree 编程风格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实践经验"><span class="toc-number">6.</span> <span class="toc-text">实践经验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#柯里化中把要操作的数据放到最后"><span class="toc-number">6.1.</span> <span class="toc-text">柯里化中把要操作的数据放到最后</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数组合中函数要求单输入"><span class="toc-number">6.2.</span> <span class="toc-text">函数组合中函数要求单输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数组合的-debug"><span class="toc-number">6.3.</span> <span class="toc-text">函数组合的 debug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多参考-Ramda"><span class="toc-number">6.4.</span> <span class="toc-text">多参考 Ramda</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式编程的优-缺点"><span class="toc-number">7.</span> <span class="toc-text">函数式编程的优&#x2F;缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">8.</span> <span class="toc-text">Reference</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Edsyang</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">山外1: 函数式编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-13 15:35:37"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-13</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-03 03:09:19"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JS/">JS</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JS/JS-%E4%B8%AD%E7%9A%84%E2%80%9C%E5%85%AD%E5%BA%A7%E5%A4%A7%E5%B1%B1%E2%80%9D/">JS 中的“六座大山”</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5.1k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 16 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>函数式以优雅、简单的特点开始重新风靡整个编程界, 主流语言在设计时会更多参考函数式特性, 前端领域也能看到很多函数式编程的影子: ES6 的箭头函数、Redux 引入 Elm 降低 Flux 的复杂性、React 16.8 之后的 Hooks 使得 pure functional components 成为可能</p>
<h2 id="代码思维的演变"><a href="#代码思维的演变" class="headerlink" title="代码思维的演变"></a>代码思维的演变</h2><ol>
<li><p>命令式编程</p>
<p>用传统的编程思维, 上来就撸代码, 但是会产生一对中间临时变量, 同时掺杂了大量逻辑, 通常一个函数需要从头读到尾才知道他具体做了什么, 一旦出现问题很难定位</p>
</li>
<li><p>面向对象编程</p>
</li>
<li><p><strong>函数式编程</strong></p>
<p>函数式编程的思维过程会着重函数, 而不是过程; 强调的是如何通过函数的组合变换去解决问题, 而不是通过些什么样的语句去解决问题, 当代码越来越多的时候, 函数的拆分和组合就表现出它的优势</p>
</li>
</ol>
<h2 id="为什么叫函数式编程"><a href="#为什么叫函数式编程" class="headerlink" title="为什么叫函数式编程"></a>为什么叫函数式编程</h2><p>函数是一种描述集合和集合之前的<strong>转换关系</strong>, 输入通过函数都会返回<strong>有且只有一个</strong>输出值</p>
<p>函数实际上是一个关系, 或者说以一种映射, 这种映射关系是可以组合的, 只要知道一个函数的输出类型可以匹配另一个函数的输入, 那他们就可以进行组合, 如 redux 中比较经典的 compose 函数</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>{</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) <span class="keyword">return</span> funcs[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>在编程中, 其实需要处理的只有“数据”和“关系”, 而关系就是函数; 所谓的编程工作不过就是在找一种<strong>映射关系</strong>, 一旦找到, 问题就解决了, 剩下的事情就是让数据流过这种关系, 然后转换成另一个数据罢了</p>
<p>就像流水线一样, 把输入当作原料, 把输出当作产品, <strong>数据可以不断地从一个函数的输出可以流入另一个函数输入</strong>, 最后在输出结果</p>
<p>所以函数式编程, 就是强调在编程过程中把更多的关注点放在如何去<strong>构建关系</strong>, 通过构建一条高效的流水线, 一次解决所有问题, 而不是把精力分散在不同的加工厂中来回奔波传递数据</p>
<h2 id="函数式编程的特点"><a href="#函数式编程的特点" class="headerlink" title="函数式编程的特点"></a>函数式编程的特点</h2><h3 id="函数是“一等公民”-First-Class-Functions"><a href="#函数是“一等公民”-First-Class-Functions" class="headerlink" title="函数是“一等公民” (First-Class Functions)"></a>函数是“一等公民” (First-Class Functions)</h3><p>这是函数式编程得以实现的前提, 因为基本的操作都是在操作函数; 这个特性意味着函数与其它数据类型一样, 处于平等地位, 可以复制给其它变量, 也可以作为参数传入另一个函数, 或者作为别的函数的返回值</p>
<h3 id="声明式编程-Declarative-Programming"><a href="#声明式编程-Declarative-Programming" class="headerlink" title="声明式编程 (Declarative Programming)"></a>声明式编程 (Declarative Programming)</h3><p>函数式编程大多时间都是在声明需要做什么, 而不是怎么去做; 这种编程风格成为声明式编程; 这样的优点是<strong>代码可读性高</strong>, 因为声明式代码大多都是接近自然语言的, 同时解放了大量的人力, 因为他不关心具体的实现, 因此它可以把优化能力交给具体的实现, 也方便进行分工协作</p>
<blockquote>
<p>SQL 语句就是声明式的, 你无需关心 Select 语句是如何实现的, 不同的数据库会去实现它自己的方法并且优化; React 也是声明式的, 你只要描述你的 UI, 接下来状态变化后 UI 如何更新, 是 React 在运行时帮你处理的, 而不是靠你自己去渲染和优化 diff 算法</p>
</blockquote>
<h3 id="惰性执行（Lazy-Evaluation）"><a href="#惰性执行（Lazy-Evaluation）" class="headerlink" title="惰性执行（Lazy Evaluation）"></a>惰性执行（Lazy Evaluation）</h3><p>所谓惰性执行指的是函数只在需要的时候执行, 即不产生无意义的中间变量; 函数式编程跟命令式编程最大的区别就在于几乎没有中间变量, 它从头到尾都在写函数, 只有在最后的时候才通过调用函数产生实际的结果</p>
<h3 id="无状态和数据不可变-Statelessness-and-Immutable-data"><a href="#无状态和数据不可变-Statelessness-and-Immutable-data" class="headerlink" title="无状态和数据不可变 (Statelessness and Immutable data)"></a>无状态和数据不可变 (Statelessness and Immutable data)</h3><p>函数式编程的核心概念</p>
<ul>
<li><strong>数据不可变</strong>: 它要求你所有的数据都是不可变的, 这意味着如果你想修改一个对象, 那你应该创建一个新的对象用来修改, 而不是修改已有的对象</li>
<li><strong>无状态</strong>: 主要是强调对于一个函数, 不管你何时运行, 它都应该像第一次运行一样, 给定相同的输入, 给出相同的输出, 完全不依赖外部状态的变化</li>
</ul>
<p>为了实现这个目标, 函数式编程提出函数应该具备的特性: 没有副作用和纯函数</p>
<h3 id="没有副作用（No-Side-Effects）"><a href="#没有副作用（No-Side-Effects）" class="headerlink" title="没有副作用（No Side Effects）"></a>没有副作用（No Side Effects）</h3><p>没有副作用的含义是: 在完成函数主要功能之外完成的其它副要功能</p>
<p>在函数中最主要的功能当然是根据输入返回结果, 而在函数中最常见的副作用就是随意操纵外部变量; 由于 JS 中对象传递的是引用地址, 哪怕用 const 关键词声明对象, 它依旧是可以变的; 而正是这个“漏洞”让我们有机会随意修改对象</p>
<p>保证函数没有副作用, 一来能保证数据的不可变性, 二来能避免很多因为共享状态带来的问题; 当一个人维护代码时候可能还不明显, 但随着项目的迭代, 项目参与人数增加, 大家对同一变量的依赖和引用越来越多, 这种问题会越来越严重; 最终可能连维护者自己都不清楚变量到底是在哪里被改变而产生 Bug</p>
<h3 id="纯函数-pure-functions"><a href="#纯函数-pure-functions" class="headerlink" title="纯函数 (pure functions)"></a>纯函数 (pure functions)</h3><p>纯函数算是在 “没有副作用” 的要求上再进一步了, 就像 Redux 的三大原则中, 它要求所有的修改必须使用纯函数</p>
<p>其实纯函数的概念很简单就是两点</p>
<ul>
<li><strong>不依赖外部状态（无状态）</strong>: 函数的的运行结果不依赖全局变量, this 指针, IO 操作等</li>
<li><strong>没有副作用（数据不变）</strong>: 不修改全局变量, 不修改入参</li>
</ul>
<p>所以纯函数才是真正意义上的 “函数”, 它意味着<strong>相同的输入, 永远会得到相同的输出</strong></p>
<p>举个例子</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非纯函数</span></span><br><span class="line"><span class="keyword">const</span> curUser = { <span class="attr">name</span>: <span class="string">'aa'</span> };</span><br><span class="line"><span class="keyword">const</span> saySth = <span class="function"><span class="params">str</span> =&gt;</span> curUser.name + <span class="string">': '</span> + str; <span class="comment">// 引用了全局变量</span></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="function">(<span class="params">user, name</span>) =&gt;</span> user.name = name; <span class="comment">// 修改了输入参数</span></span><br><span class="line">changeName(curUser, <span class="string">'bb'</span>);</span><br><span class="line">saySth(<span class="string">'hello!'</span>); <span class="comment">// bb: hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 纯函数</span></span><br><span class="line"><span class="keyword">const</span> curUser = { <span class="attr">name</span>: <span class="string">'aa'</span> };</span><br><span class="line"><span class="keyword">const</span> saySth = <span class="function">(<span class="params">user, str</span>) =&gt;</span> user.name + <span class="string">': '</span> + str; <span class="comment">// 不依赖外部变量</span></span><br><span class="line"><span class="keyword">const</span> changeName = <span class="function">(<span class="params">user, name</span>) =&gt;</span> ({ ...user, name }) <span class="comment">// 未修改外部变量</span></span><br><span class="line"><span class="keyword">const</span> newUser = changeName(curUser, <span class="string">'bb'</span>); <span class="comment">// { name: 'aa' }</span></span><br><span class="line">saySth(curUser, <span class="string">'hello'</span>); <span class="comment">// aa: hello!</span></span><br><span class="line">saySth(newUser, <span class="string">'hello'</span>); <span class="comment">// bb: hello!</span></span><br></pre></td></tr></tbody></table></figure>

<p>纯函数的意义</p>
<ul>
<li><strong>便于测试和优化</strong>: 这个意义在实际项目开发中意义非常大, 由于纯函数对于相同的输入永远会返回相同的结果, 因此我们可以轻松断言函数的执行结果, 同时也可以保证函数的优化不会影响其他代码的执行; 这十分符合测试驱动开发 TDD（Test-Driven Development ) 的思想, 这样产生的代码往往健壮性更强</li>
<li><strong>可缓存性</strong>: 因为相同的输入总是可以返回相同的输出, 因此, 我们可以提前缓存函数的执行结果</li>
<li><strong>自文档化</strong>: 由于纯函数没有副作用, 所以其依赖很明确, 因此更易于观察和理解（配合[类型签名](#hindly-milner 类型签名）更佳)</li>
<li><strong>更少的 Bug</strong>: 使用纯函数意味着你的函数中<strong>不存在指向不明的 this, 不存在对全局变量的引用, 不存在对参数的修改</strong>, 这些共享状态往往是绝大多数 bug 的源头</li>
</ul>
<blockquote>
<p>Hindly Milner 类型签名<br><code>:: String -&gt; Object</code><br>这叫类型签名, 最早是在 Hindly-Milner 类型系统中提出来的<br>引入它的好处就是能暴露函数的行为和目的, 方便了解语义; 有时候一个函数很长, 光从代码上很难理解他道理做了什么, 而加上类型签名, 至少能知道每一步它做了哪些转换, 最后输出了一个什么样的结果<br>同时类型签名可以避免在合并函数的时候输入和输出的类型不一致</p>
</blockquote>
<h2 id="流水线的构建"><a href="#流水线的构建" class="headerlink" title="流水线的构建"></a>流水线的构建</h2><h3 id="加工站-函数柯里化-Currying"><a href="#加工站-函数柯里化-Currying" class="headerlink" title="加工站 - 函数柯里化 (Currying)"></a>加工站 - 函数柯里化 (Currying)</h3><p>柯里化是将一个多元函数, 转换成一个依次调用的<strong>单元函数</strong>, 处理结果是<strong>单输入</strong>的</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(a, b, c) -&gt; f(a)(b)(c)</span><br></pre></td></tr></tbody></table></figure>

<p>为什么单元函数很重要? 因为函数的返回值有且只有一个, 如果想顺利的组装流水线, 那就必须保证每个加工站的输出刚好能流向下一个工作站的输入; 因此, <strong>在流水线上的加工站必须都是单元函数</strong></p>
<h4 id="部分函数应用-vs-柯里化"><a href="#部分函数应用-vs-柯里化" class="headerlink" title="部分函数应用 vs 柯里化"></a>部分函数应用 vs 柯里化</h4><p>部分函数应用(Partial Function Application): 强调的是固定一定的参数, 返回一个<strong>更小元的函数</strong></p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line">f(a, b, c) -&gt; f(a)(b)(c)</span><br><span class="line"><span class="comment">// 部分函数调用</span></span><br><span class="line">f(a, b, c) -&gt; f(a)(b, c) / f(a, b)(c)</span><br></pre></td></tr></tbody></table></figure>

<p>柯里化(Currying) 强调的是<strong>生成单元函数</strong>, 部分函数应用强调的<strong>固定任意元参数</strong>, 而常用的是部分函数应用, 这样的好处是可以固定参数, 降低函数通用性, 提高函数的适用性</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设一个通用的请求 API</span></span><br><span class="line"><span class="keyword">const</span> request = <span class="function">(<span class="params">type, url, options</span>) =&gt;</span> ...</span><br><span class="line"><span class="comment">// GET 请求</span></span><br><span class="line">request(<span class="string">'GET'</span>, <span class="string">'http://....'</span>)</span><br><span class="line"><span class="comment">// POST 请求</span></span><br><span class="line">request(<span class="string">'POST'</span>, <span class="string">'http://....'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是通过部分调用后, 我们可以抽出特定 type 的 request</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">get</span> = request('GET');</span><br><span class="line"><span class="keyword">get</span>('http://', {..})</span><br></pre></td></tr></tbody></table></figure>

<h4 id="高级柯里化"><a href="#高级柯里化" class="headerlink" title="高级柯里化"></a>高级柯里化</h4><p>很多库中都提供了 curry 函数的实现; 高级柯里化, 即对 curry 函数做了很多优化, 导致实现的柯里化并不是纯粹的柯里化, 这些版本实现可以根据输入的参数个数, <strong>返回一个柯里化函数/结果值</strong>; 即, <strong>如果给的参数个数满足函数条件, 则返回值</strong>, 这样可以解决一个问题就是如果一个函数是多输入, 就可以避免使用 <code>()()()</code> 这种方式传参了</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = R.curry(<span class="function">(<span class="params">x, y, z</span>) =&gt;</span> x + y + z);</span><br><span class="line"><span class="keyword">const</span> add7 = add(<span class="number">7</span>);</span><br><span class="line">add7(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="keyword">const</span> add1_2 = add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">add1_2(<span class="number">7</span>); <span class="comment">// 10</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>可以用高级柯里化去实现部分函数应用, 但是柯里化不等于部分函数应用</strong></p>
<h4 id="柯里化的应用"><a href="#柯里化的应用" class="headerlink" title="柯里化的应用"></a>柯里化的应用</h4><p>通常可以使用柯里化把为了某个函数变的单值化, 这样可以增加函数的多样性, 使其适用性更强</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> replace = curry(<span class="function">(<span class="params">a, b, str</span>) =&gt;</span> str.replace(a, b));</span><br><span class="line"><span class="keyword">const</span> replaceSpaceWith = replace(<span class="regexp">/\s*/</span>);</span><br><span class="line"><span class="keyword">const</span> replaceSpaceWithComma = replaceSpaceWith(<span class="string">','</span>);</span><br><span class="line"><span class="keyword">const</span> replaceSpaceWithDash = replaceSpaceWith(<span class="string">'-'</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>通过这种方式, 从一个 replace 函数中产生很多新函数, 可以在各种场合进行使用</p>
<p>更重要的是, <strong>单值函数是函数组合的基础</strong></p>
<h3 id="流水线-函数组合-Compose"><a href="#流水线-函数组合-Compose" class="headerlink" title="流水线 - 函数组合 (Compose)"></a>流水线 - 函数组合 (Compose)</h3><p>函数组合的目的是将多个函数组合成一个函数</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> fg = compose(f, g);</span><br><span class="line">fg(<span class="number">1</span>); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure>
<p>compose 实现了一个简单的功能: 形成了一个全新的函数, 而这个函数就是一条从 g -&gt; f 的流水线, 同时 compose 其实是满足结合律的</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compose(f, compose(g, t)) = compose(compose(f, g), t) = f(g(t(x)))</span><br></pre></td></tr></tbody></table></figure>
<p>只要顺序一致, 最后的结果是一致的, 因此可以写个更高级的 compose, 支持多个函数组合</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">compose(f, g, t) =&gt; <span class="function"><span class="params">x</span> =&gt;</span> f(g(t(x)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单实现</span></span><br><span class="line"><span class="keyword">const</span> compose = <span class="function">(<span class="params">...fns</span>) =&gt;</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> fns.reduceRight(<span class="function">(<span class="params">val, fn</span>) =&gt;</span> fn.apply(<span class="literal">null</span>, [].concat(val)), args);</span><br><span class="line"><span class="keyword">const</span> f = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> g = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> t = <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y;</span><br><span class="line"><span class="keyword">let</span> fgt = compose(f, g, t);</span><br><span class="line">fgt(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3 -&gt; 6 -&gt; 7</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="函数组合应用"><a href="#函数组合应用" class="headerlink" title="函数组合应用"></a>函数组合应用</h4><p>实现一个小功能, 将数组最后一个元素大写, 假设 log、head、reverse、toUpperCase 函数存在</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 命令式写法</span></span><br><span class="line">log(toUpperCase(head(reverse(arr))));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 面向对象写法</span></span><br><span class="line"><span class="comment">// 链式调用顺眼, 但是原型链上可供链式调用的函数有限, 但是需求无限, 限制了逻辑表现力</span></span><br><span class="line">arr.reverse()</span><br><span class="line">   .head()</span><br><span class="line">   .toUpperCase()</span><br><span class="line">   .log()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过函数组合</span></span><br><span class="line"><span class="keyword">const</span> upperLastIter = compose(log, toUpperCase, head, reverse);</span><br></pre></td></tr></tbody></table></figure>
<p>upperLastIter 完成了一套流水线, 所有经过这条流水线的参数都会经历: reverse -&gt; head -&gt; toUpperCase -&gt; log 这些函数加工, 最后生成结果</p>
<p>最完美的是, 这些函数都是非常简单的纯函数, 可以任意组合、使用, 不用有任何顾忌</p>
<p>而这个就是所谓的<strong>管道(pipe)</strong> 的概念, 在 Linux 中经常会用到, 如 ps、grep 的组合</p>
<figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br></pre></td></tr></tbody></table></figure>
<p>只是管道的执行方向和 compose(从右到左的组合) 相反, 因为很多函数库(Lodash、Ramda) 中也提供了另一种组合方式: pipe(从左往右的组合)</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> upperLastItem = R.pipe(reverse, head, toUpperCase, log);</span><br></pre></td></tr></tbody></table></figure>
<p>其实函数式编程的理念和 Linux 的设计哲学很像: <em>有众多单一目的的小程序, 一个程序只实现一个功能, 多个程序组合完成复杂任务</em></p>
<h4 id="函数组合的好处"><a href="#函数组合的好处" class="headerlink" title="函数组合的好处"></a>函数组合的好处</h4><p>让代码变得简单且富有可读性, 通过不同的组合方式, 可以轻易组合出其它常用函数, 让代码更具表现力</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合方式 1</span></span><br><span class="line"><span class="keyword">const</span> last = compose(head, reverse);</span><br><span class="line"><span class="keyword">const</span> shout = compose(log, toUpperCase);</span><br><span class="line"><span class="keyword">const</span> shoutLast = compose(shout, last);</span><br><span class="line"><span class="comment">// 组合方式 2</span></span><br><span class="line"><span class="keyword">const</span> lastUppder = compose(toUpperCase, head, reverse);</span><br><span class="line"><span class="keyword">const</span> logLastUpper = compose(log, lastUppder);</span><br></pre></td></tr></tbody></table></figure>
<p>这个过程, 就像搭乐高积木一样; 由此可见, 大型的程序, 都可以通过这样一步步拆分组合实现, 而剩下要做的, 就是去构造足够多的积木块(函数)</p>
<h3 id="compose-gt-Pointfree-编程风格"><a href="#compose-gt-Pointfree-编程风格" class="headerlink" title="compose -> Pointfree 编程风格"></a>compose -&gt; Pointfree 编程风格</h3><p>强调在整个函数编写过程中不出现参数(point), 而只是通过函数的组合生成新的函数, 实际数据只需要在最后使用函数的时候再传入即可</p>
<p>优点</p>
<ul>
<li>无需考虑参数命名</li>
<li>关注点集中: 无需考虑数据, 只需要把精力集中在转换关系上</li>
<li>代码简洁: 可以省去通过中间变量不断的去传递数据的过程</li>
<li>可读性强: 一眼就可以看出来数据的整个转换关系</li>
</ul>
<blockquote>
<p>注意: 学习这种编程风格并不意味着要强迫自己做到一个参数都不能出现, 如很多基础函数, 本身编写就不是 Pointfree 的, 函数式编程也不是所有场合都完全适用的, 具体情况具体分析</p>
</blockquote>
<p>学习各种编程范式的最终目的都是为了让自己的<strong>编码更高效, 易懂, 同时减少出错概率</strong>, 不能因为学了一种编程范式, 而导致自己的编程成本增加, 这就有点本末倒置了</p>
<h2 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h2><p>使用柯里化和函数组合的时候, 有一些经验可以借鉴一下</p>
<h3 id="柯里化中把要操作的数据放到最后"><a href="#柯里化中把要操作的数据放到最后" class="headerlink" title="柯里化中把要操作的数据放到最后"></a>柯里化中把要操作的数据放到最后</h3><p>因为输出的通常是需要操作的数据, 这样当固定了之前的参数(也可成为<strong>配置</strong>)后, 可以变成一个单元函数, 直接被函数组合使用, 这也是其它函数式语言遵循的规范</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">x, str</span>) =&gt;</span> str.split(x));</span><br><span class="line"><span class="keyword">const</span> join = curry(<span class="function">(<span class="params">x, arr</span>) =&gt;</span> arr.join(x));</span><br><span class="line"><span class="keyword">const</span> replaceSpaceWithComma = compose(join(<span class="string">','</span>), split(<span class="string">' '</span>));</span><br><span class="line"><span class="keyword">const</span> replaceCommaWithDash = compose(join(<span class="string">'-'</span>), split(<span class="string">','</span>));</span><br></pre></td></tr></tbody></table></figure>

<p>但是如果这些函数没遵循这个约定, 函数该如何组合? 很多库都提供了占位符的概念, 如 Ramda 提供了一个占位符号(<code>R.__</code>), 假设我们的 split 把 str 放在首位</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> split = curry(<span class="function">(<span class="params">str, x</span>) =&gt;</span> str.split(x));</span><br><span class="line"><span class="keyword">const</span> replaceSpaceWithComma = compose(join(<span class="string">','</span>), split(R.__, <span class="string">' '</span>));</span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数组合中函数要求单输入"><a href="#函数组合中函数要求单输入" class="headerlink" title="函数组合中函数要求单输入"></a>函数组合中函数要求单输入</h3><p>函数组合有个使用要点, 就是中间的函数一定是<strong>单输入</strong>的, 因为函数的输出都是单个的(数组也只是一个元素)</p>
<h3 id="函数组合的-debug"><a href="#函数组合的-debug" class="headerlink" title="函数组合的 debug"></a>函数组合的 debug</h3><p>当遇到函数出错的时候, 可以借助一个辅助函数 <code>trace</code>, 会临时输出当前阶段的结果, 方便知道在哪个环节出错了</p>
<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> trace = curry(<span class="function">(<span class="params">tip, x</span>) =&gt;</span> {</span><br><span class="line">   <span class="built_in">console</span>.log(tip, x);</span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">});</span><br><span class="line"><span class="keyword">const</span> lastUpper = compose(toUpperCase, head, trace(<span class="string">'after reverse'</span>), reverse);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="多参考-Ramda"><a href="#多参考-Ramda" class="headerlink" title="多参考 Ramda"></a>多参考 Ramda</h3><p>现有的函数式编程工具库很多, Lodash/fp 也提供了, 但是不是很推荐使用 Lodash/fp 的函数库, 因为它的很多函数把需要处理的参数放在了首位（ 例如 map ）这不符合我们之前说的最佳实践</p>
<p>这里推荐使用 <a href="https://ramda.cn/docs/" target="_blank" rel="noopener">Ramda</a>, 它应该是目前最符合函数式编程的工具库, 它里面的所有函数都是 curry 的, 而且需要操作的参数都是放在最后的。上述的 split, join, replace 这些基本的都在 Ramda 中可以直接使用, 它一共提供了 200 多个超实用的函数, 合理使用可以大大提高你的编程效率</p>
<h2 id="函数式编程的优-缺点"><a href="#函数式编程的优-缺点" class="headerlink" title="函数式编程的优/缺点"></a>函数式编程的优/缺点</h2><p>优点(Less code, fewer bugs)</p>
<ul>
<li><strong>代码简洁, 开发快速</strong>: 函数式编程使用大量函数组合, 函数复用率高, 减少代码重复, 因此程序较短, 开发速度快</li>
<li><strong>接近自然语言, 易于理解</strong>: 函数式编程大量使用声明式代码, 基本都是接近自然语言的, 加上它没有乱七八糟的循环, 判断的嵌套, 因此特别易于理解</li>
<li><strong>易于“并发编程”</strong>: 函数式编程没有副作用, 所以不需要考虑死锁(Deadlock), 所以根本不存在“锁”线程的问题</li>
<li><strong>更少的出错概率</strong>: 因为每个函数都很小, 而且相同输入永远可以得到相同输出, 因此测试很简单, 同时函数式编程强调使用纯函数, 没有副作用, 因此很少出现奇怪的 bug</li>
</ul>
<p>缺点</p>
<ul>
<li><strong>性能</strong>: 函数式编程相对于指令式编程, 性能绝对是一个短板, 因为它往往会对一个方法进行过度包装, 从而产生上下文切换的性能开销; 同时, 在 JS 这种非函数式语言中, 函数式的方式必然会比直接写语句指令慢（引擎会针对很多指令做特别优化）; 就拿原生方法 map 来说, 它就要比纯循环语句实现迭代慢 8 倍</li>
<li><strong>资源占用</strong>: 在 JS 中为了实现对象状态的不可变, 往往会创建新的对象, 因此, 它对垃圾回收（Garbage Collection）所产生的压力远远超过其他编程方式。这在某些场合会产生十分严重的问题</li>
<li><strong>递归陷阱</strong>: 在函数式编程中, 为了实现迭代, 通常会采用递归操作, 为了减少递归的性能开销, 我们往往会把递归写成尾递归形式, 以便让解析器进行优化; 但是众所周知, JS 是不支持尾递归优化的（虽然 ES6 中将尾递归优化作为了一个规范, 但是真正实现的少之又少）</li>
</ul>
<p>因此, 在性能要求很严格的场合, 函数式编程并不是太合适的选择</p>
<p>学习函数式编程真正的意义在于: 让你意识到在指令式编程, 面向对象编程之外, 还有一种全新的编程思路, 一种用函数的角度去抽象问题的思路。学习函数式编程能大大丰富你的武器库, 不然, 当你手中只有一个锤子, 你看什么都像钉子</p>
<p>我们完全可以在日常工作中将函数式编程作为一种辅助手段, 在条件允许的前提下, 借鉴函数式编程中的思路, 例如:</p>
<ul>
<li>多使用纯函数减少副作用的影响</li>
<li>使用柯里化增加函数适用率</li>
<li>使用 Pointfree 编程风格, 减少无意义的中间变量, 让代码更且可读性</li>
<li>…</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://juejin.im/post/5d70e25de51d453c11684cc4#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E6%9E%84%E5%BB%BA" target="_blank" rel="noopener">简明 JavaScript 函数式编程——入门篇</a></li>
<li><a href="https://juejin.im/post/5e09554bf265da33b5074d7f" target="_blank" rel="noopener">函数式编程进阶: 杰克船长的黑珍珠号</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1966861494@qq.com">Edsyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lagerstroemia.com.cn/2020/04/13/js/mount/function/">http://blog.lagerstroemia.com.cn/2020/04/13/js/mount/function/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lagerstroemia.com.cn" target="_blank">Edsyang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/17/frame/vue/vue3/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue3 源码解析</div></div></a></div><div class="next-post pull_right"><a href="/2020/04/12/ts/tsconfig/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">tsconfig 常用配置</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WgFk4Onl7sisfXpq9vHcehGJ-gzGzoHsz',
  appKey: '3DLR7iLY5al5dbIdo9kWnDHU',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Edsyang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19038398号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>