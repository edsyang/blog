<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>M3: 同异步 / DOM 事件 | Edsyang</title><meta name="description" content="同异步js在执行的时候, 浏览器会把代码分为同步执行任务和异步执行任务  同步任务: 当前任务是按顺序执行, 如果当前这个任务没有完成, 下一个任务不能开始 异步任务: 当前任务需要过一段时间或者执行时机不确定(定时器里面的回调函数就是过一段时间才会执行, 事件就是执行时机不确定), 浏览器不会等着这件事情完成, 而是先把这些任务记录在⼀个地方(等待任务队列), 继续执行后面的任务, 等把所有的同"><meta name="keywords" content="Personal blog about font-end technology &amp; record others"><meta name="author" content="Edsyang,1966861494@qq.com"><meta name="copyright" content="Edsyang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="M3: 同异步 / DOM 事件"><meta name="twitter:description" content="同异步js在执行的时候, 浏览器会把代码分为同步执行任务和异步执行任务  同步任务: 当前任务是按顺序执行, 如果当前这个任务没有完成, 下一个任务不能开始 异步任务: 当前任务需要过一段时间或者执行时机不确定(定时器里面的回调函数就是过一段时间才会执行, 事件就是执行时机不确定), 浏览器不会等着这件事情完成, 而是先把这些任务记录在⼀个地方(等待任务队列), 继续执行后面的任务, 等把所有的同"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="M3: 同异步 / DOM 事件"><meta property="og:url" content="http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m3/"><meta property="og:site_name" content="Edsyang"><meta property="og:description" content="同异步js在执行的时候, 浏览器会把代码分为同步执行任务和异步执行任务  同步任务: 当前任务是按顺序执行, 如果当前这个任务没有完成, 下一个任务不能开始 异步任务: 当前任务需要过一段时间或者执行时机不确定(定时器里面的回调函数就是过一段时间才会执行, 事件就是执行时机不确定), 浏览器不会等着这件事情完成, 而是先把这些任务记录在⼀个地方(等待任务队列), 继续执行后面的任务, 等把所有的同"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2020-02-17T14:16:48.569Z"><meta property="article:modified_time" content="2020-05-03T03:09:33.841Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m3/"><link rel="prev" title="M4: 设计模式" href="http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m4/"><link rel="next" title="M2: 面向对象(OOP)" href="http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Edsyang","link":"链接: ","source":"来源: Edsyang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Edsyang" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">112</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">37</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#同异步"><span class="toc-number">1.</span> <span class="toc-text">同异步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的异步情形"><span class="toc-number">1.1.</span> <span class="toc-text">常见的异步情形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器实现异步的原理"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器实现异步的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise"><span class="toc-number">1.3.</span> <span class="toc-text">Promise</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-all"><span class="toc-number">1.3.1.</span> <span class="toc-text">Promise.all([])</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise-A"><span class="toc-number">1.3.2.</span> <span class="toc-text">Promise A+</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简化版实现-Promise"><span class="toc-number">1.3.3.</span> <span class="toc-text">简化版实现 Promise</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宏任务-amp-微任务"><span class="toc-number">1.4.</span> <span class="toc-text">宏任务 &amp; 微任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-amp-await"><span class="toc-number">1.5.</span> <span class="toc-text">async &amp; await</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM-事件"><span class="toc-number">2.</span> <span class="toc-text">DOM 事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见事件"><span class="toc-number">2.1.</span> <span class="toc-text">常见事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件对象"><span class="toc-number">2.2.</span> <span class="toc-text">事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认事件和默认行为"><span class="toc-number">2.3.</span> <span class="toc-text">默认事件和默认行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件传播机制"><span class="toc-number">2.4.</span> <span class="toc-text">事件传播机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件委托"><span class="toc-number">2.5.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DOM0-DOM2级事件"><span class="toc-number">2.6.</span> <span class="toc-text">DOM0&#x2F;DOM2级事件</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Edsyang</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">M3: 同异步 / DOM 事件</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-02-17 14:16:48"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-03 03:09:33"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JS/">JS</a><i class="fa fa-angle-right post-meta__separator" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JS/JS-%E4%B8%AD%E7%9A%84%E2%80%9C%E5%85%AD%E5%BA%A7%E5%A4%A7%E5%B1%B1%E2%80%9D/">JS 中的“六座大山”</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">5k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 17 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="同异步"><a href="#同异步" class="headerlink" title="同异步"></a>同异步</h2><p>js在执行的时候, <strong>浏览器</strong>会把代码分为同步执行任务和异步执行任务</p>
<ol>
<li>同步任务: 当前任务是按顺序执行, 如果当前这个任务没有完成, 下一个任务不能开始</li>
<li>异步任务: 当前任务需要过一段时间或者执行时机不确定(定时器里面的回调函数就是过一段时间才会执行, 事件就是执行时机不确定), 浏览器不会等着这件事情完成, 而是先把这些任务记录在⼀个地方(等待任务队列), 继续执行后面的任务, 等把所有的同步任务都执行完之后再去看这些异步任务<blockquote>
<p><strong>异步的实质是事件发生促使程序的执行点来回跳转</strong></p>
</blockquote>
</li>
</ol>
<h3 id="常见的异步情形"><a href="#常见的异步情形" class="headerlink" title="常见的异步情形"></a>常见的异步情形</h3><ul>
<li>定时器的回调函数都是异步执行</li>
<li>所有的事件函数都是异步执行</li>
<li>AJAX的异步情形: open 的第三个参数是 true 就是异步</li>
<li>回调函数也可以是异步执行<blockquote>
<p>异步编程: 编写异步处理程序, JS 语言最大的特色就是<strong>异步和事件机制</strong></p>
</blockquote>
</li>
</ul>
<h3 id="浏览器实现异步的原理"><a href="#浏览器实现异步的原理" class="headerlink" title="浏览器实现异步的原理"></a>浏览器实现异步的原理</h3><p>js 是一种单线程的编程语言, 一次只能干一个事; 能够实现异步, 依赖于<strong>浏览器的任务队列机制</strong>, 任务队列分为两种</p>
<ol>
<li>主任务队列: 主任务队列中放的都是当前需要立即执行的同步任务</li>
<li>等待任务队列: 等待任务队列中放的都是不需要立即执行的异步任务, 等待任务队列只负责记录异步任务是否满足条件, 满足条件会将其再放到主任务队列中执行<blockquote>
<p>流程: 首先执行主任务队列中的同步任务, 当主任务队列中的同步任务「都执行完成后」, 再去等待任务队列看哪些异步任务满足条件、可以执⾏了(等待任务队列中的任务满⾜了执行条件, 例如定时器的时间)就执行, 如果有多个任务都满足条件, 那么看谁先满足执行条件就先执行谁</p>
</blockquote>
</li>
</ol>
<h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>ES6 浏览器新增的内置类, <code>new Promise()</code>, 用来管理 JS 中的异步编程「创建 Promise 实例时传递的回调函数是同步执行的, then 里面的回调函数是异步执行的」</p>
<blockquote>
<p>使用 Promise 可以解决回调地狱问题</p>
</blockquote>
<p>Promise 实例（对象）的三种状态</p>
<ul>
<li>pending（已经准备好, 初始化成功, 开始执行异步任务）</li>
<li>fulfilled（成功: 异步处理成功）</li>
<li>rejected（失败: 异步处理失败）</li>
</ul>
<blockquote>
<p>Promise 对象的状态是由 pending 变为 fulfilled / rejected, 状态一旦发生变更就会凝固（不会再发生变化）</p>
</blockquote>
<p>Promise 实例中的回调函数是同步执行的, 里面放的都是异步处理的任务</p>
<ul>
<li>resolve 是一个函数, 在异步处理成功后执行, 有两个作用<ol>
<li>修改 Promise 实例的状态从 pending 变为 fulfilled</li>
<li>执行一个事件池, 这个事件池中收集了所有then方法的第一个回调函数</li>
</ol>
</li>
<li>reject 是一个函数, 在异步处理失败后执行, 有两个作用<ol>
<li>修改 Promise 实例的状态从 pending 变为 rejected</li>
<li>执行一个事件池, 这个事件池中收集了所有 then 方法的第二个回调函数<blockquote>
<p>resolve 或 reject 在执行的时候收到的实参会传递给第一个 then 方法的回调函</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<p>then 方法中的回调函数执行规律</p>
<ul>
<li>第一个 then 方法比较特殊, 它的两个回调函数中哪个能执行, 取决于创建 Promise 实例时到底是 resolve 还是 reject; 如果是 resolve, 第一个 then 的第一个回调函数执行; 如果是 reject, 第一个 then 的第二个回调函数执行</li>
<li>后面的 then 方法中哪个回调函数能执行, 取决于前面 then 方法中的执行情况（两种）<ol>
<li>前一个 then 方法的回调函数没有返回 Promise 实例时, 无论前面的 then 是哪个回调函数执行, 都会执行第一个回调函数; 前面 then 的回调函数的返回值会传给下一个 then 回调函数; 如果前面 then 回调函数执行时报错了, 就会执行第二个, 并且报错信息会传递给第二个回调函数</li>
<li>当前面的 then 方法的回调函数返回了 Promise 实例时; 后面 then 方法的哪个回调函数能执行, 取决于前面 then 方法返回的 Promise 实例的状态; 如果前面返回的实例 resolve, 后面then的第一个回调函数就会执行; 如果前面返回的实例 reject, 后面 then 的第二个回调函数就会执行; 并且前面 then 的回调函数返回的实例 resolve 或 reject 执行时收到的实参, 会传给下一个 then 要执行的回调函数</li>
</ol>
</li>
</ul>
<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all([])"></a>Promise.all([])</h4><ul>
<li>Promise.all( [ promise实例1, promise实例2… ] ) <ul>
<li>Promise 的静态方法</li>
<li>接收一个数组, 数组项都是 Promise 实例</li>
<li>返回一个新的 Promise 实例, 如果数组中送有的 Promise 都 resolve, 新返回的 Promise 实例就是 resolve; 只要数组中有一个 reject, 新返回的 Promise 实例就是 reject</li>
</ul>
</li>
</ul>
<h4 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise A+"></a>Promise A+</h4><p>相关术语</p>
<ul>
<li>promise 是一个包含 then 方法的对象或函数, 该方法符合规范指定的行为</li>
<li>thenable 是一个包含 then 方法和对象或者函数</li>
<li>value 就是任意合法 JS 值</li>
<li>exception 就是 throw 语句抛出的值</li>
<li>reason 是一个指示 promise 为什么被 rejected 的值<figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="keyword">typeof</span> obj === <span class="string">'function'</span></span><br><span class="line"><span class="keyword">const</span> isObject = <span class="function"><span class="params">obj</span> =&gt;</span> !!(obj &amp;&amp; <span class="keyword">typeof</span> obj === <span class="string">'object'</span>)</span><br><span class="line"><span class="keyword">const</span> isThenable = <span class="function"><span class="params">obj</span> =&gt;</span> (isFunction(obj) || isObject(obj)) &amp;&amp; <span class="string">'then'</span> <span class="keyword">in</span> obj</span><br><span class="line"><span class="keyword">const</span> isPromise = <span class="function"><span class="params">promise</span> =&gt;</span> promise <span class="keyword">instanceof</span> <span class="built_in">Promise</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* promise 的三个状态 */</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">f</span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.state = PENDING;</span><br><span class="line">  <span class="keyword">this</span>.result = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.callbacks = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 切换状态</span></span><br><span class="line">  <span class="keyword">let</span> onFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> transition(<span class="keyword">this</span>, FULFILLED, value);</span><br><span class="line">  <span class="keyword">let</span> onRejected = <span class="function"><span class="params">reason</span> =&gt;</span> transition(<span class="keyword">this</span>, REJECTED, reason);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过标志保证 resolve/result 只有一次调用</span></span><br><span class="line">  <span class="keyword">let</span> ignore = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (ignore) <span class="keyword">return</span></span><br><span class="line">    ignore = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 通过 resolvePromise 对 value 进行验证</span></span><br><span class="line">    resolvePromise(<span class="keyword">this</span>, value, onFulfilled, onRejected);</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">let</span> reject = <span class="function"><span class="params">reason</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">if</span> (ignore) <span class="keyword">return</span></span><br><span class="line">    ignore = <span class="literal">true</span>;</span><br><span class="line">    onRejected(reason);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 将 resolve/reject 作为参数, 传入 f 函数</span></span><br><span class="line">    f(resolve, reject);</span><br><span class="line">    <span class="comment">// 如果 f 函数执行报错, 将该错误作为 reject 的 reason 使用</span></span><br><span class="line">  } <span class="keyword">catch</span> (error) {</span><br><span class="line">    reject(error);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* promise 的 then 方法, 接受 onFulfilled &amp; onRejected 参数 */</span></span><br><span class="line"><span class="comment">// onFulfilled, onRejected 如果是函数, 必须最多执行一次</span></span><br><span class="line"><span class="comment">// then 方法可以被调用很多次, 每次注册一组 onFulfilled 和 onRejected 的 callback,</span></span><br><span class="line"><span class="comment">// 如果被调用, 必须按照注册顺序调用</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>{</span><br><span class="line">  <span class="comment">// 满足 then 必须 return promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">let</span> callback = { onFulfilled, onRejected, resolve, reject };</span><br><span class="line">    <span class="comment">// 判断 state</span></span><br><span class="line">    <span class="comment">// 处于 pending 状态就储存到 callbacks 列表中,</span></span><br><span class="line">    <span class="comment">// 不处于 pending 状态就扔到 handCallback 处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) {</span><br><span class="line">      <span class="keyword">this</span>.callbacks.push(callback);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="comment">// 为什么要使用 setTimeout</span></span><br><span class="line">      <span class="comment">// onFulfilled or onRejected must not be called</span></span><br><span class="line">      <span class="comment">// until the execution context stack contains only platform code.</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> handCallback(callback, <span class="keyword">this</span>.state, <span class="keyword">this</span>.result), <span class="number">0</span>)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在当前 promise 和下一个 promise 之间进行状态传递 (处理 then 方法中的 onFulfilled &amp; onRejected) */</span></span><br><span class="line"><span class="comment">// then 方法返回的 promise, 也有自己的 state 和 result,</span></span><br><span class="line"><span class="comment">// 它们将由 onFulfilled 和 onRejected 的行为指定</span></span><br><span class="line"><span class="comment">// then 的核心用法是构造下一个 promise 的 result</span></span><br><span class="line"><span class="keyword">const</span> handleCallback = <span class="function">(<span class="params">callback, state, result</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">let</span> { onFulfilled, onRejected, resolve, reject } = callback;</span><br><span class="line">  <span class="keyword">try</span> {</span><br><span class="line">    <span class="comment">// 根据 state 状态判断是走 fulfilled 路径还是 rejected 路径</span></span><br><span class="line">    <span class="comment">// isFunction 判断 onFulfilled/onRejected 是否是函数,</span></span><br><span class="line">    <span class="comment">//   如果是函数, 以它们的返回值作为下一个 promise 的 result</span></span><br><span class="line">    <span class="comment">//   如果不是, 直接以当前的 promise 的 result 作为下一个 promise 的 result</span></span><br><span class="line">    <span class="keyword">if</span> (state === FULFILLED) {</span><br><span class="line">      isFunction(onFulfilled) ? resolve(onFulfilled(result)) : resolve(result);</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (state === REJECTED) {</span><br><span class="line">      isFunction(onRejected) ? reject(onRejected(result)) : reject(result);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果在执行 onFulfilled/onRejected 时抛错,</span></span><br><span class="line">    <span class="comment">// 将错误作为 下一个 promise 的 rejected reason 来用</span></span><br><span class="line">  } <span class="keyword">catch</span> (error) {</span><br><span class="line">    reject(error);</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 异步清空所有 callbacks */</span></span><br><span class="line"><span class="keyword">const</span> handleCallbacks = <span class="function">(<span class="params">callbacks, state, result</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">while</span> (callbacks.length) handleCallback(callbacks.shift(), state, result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对单个 promise 进行状态迁移 */</span></span><br><span class="line"><span class="comment">// 当状态为 pending 时, 可以转换为 fulfilled 或 rejected</span></span><br><span class="line"><span class="comment">// 但是如果当状态为 fulfilled 或 rejected 时, 不可变更到其它状态</span></span><br><span class="line"><span class="comment">// 在 fulfilled 状态时, 必须有个不可变的 value</span></span><br><span class="line"><span class="comment">// 在 rejected 状态时, 必须有个不可变的 reason</span></span><br><span class="line"><span class="keyword">const</span> transition = <span class="function">(<span class="params">promise, state, result</span>) =&gt;</span> {</span><br><span class="line">  <span class="keyword">if</span> (promise.state !== PENDING) <span class="keyword">return</span></span><br><span class="line">  <span class="comment">// 当 state 为 fulfilled 时, result 当作 value</span></span><br><span class="line">  <span class="comment">// 当 state 为 rejected 时, result 当作 reason</span></span><br><span class="line">  promise.state = state;</span><br><span class="line">  promise.result = result;</span><br><span class="line">  <span class="comment">// 调用 handleCallbacks, 当状态表更时, 异步清空所有 callbacks</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> handleCallbacks(promise.callbacks, state, result), <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对特殊的 result 进行特殊处理(一些特殊 value 被 resolve 时的特殊处理) */</span></span><br><span class="line"><span class="comment">// The Promise Resolution Procedure</span></span><br><span class="line"><span class="keyword">const</span> resolvePromise = <span class="function">(<span class="params">promise, result, resolve, reject</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// 如果 result 是当前 promise 本身, 就抛出 TypeError</span></span><br><span class="line">  <span class="keyword">if</span> (result === promise) {</span><br><span class="line">    <span class="keyword">let</span> reason = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Can not fufill promise with itself'</span>);</span><br><span class="line">    <span class="keyword">return</span> reject(reason)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果 result 是另一个 promise, 沿用它的 state 和 result 状态</span></span><br><span class="line">  <span class="keyword">if</span> (isPromise(result)) {</span><br><span class="line">    <span class="keyword">return</span> result.then(resolve, reject)</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果 result 是一个 thenable 对象</span></span><br><span class="line">  <span class="comment">// 先取出 then 函数,</span></span><br><span class="line">  <span class="comment">// 再用 new Promise 重新进入 The Promise Resolution Procedure 过程</span></span><br><span class="line">  <span class="keyword">if</span> (isThenable(result)) {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">      <span class="keyword">let</span> then = result.then;</span><br><span class="line">      <span class="keyword">if</span> (isFunction(then)) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(then.bind(result)).then(resolve, reject)</span><br><span class="line">      }</span><br><span class="line">    } <span class="keyword">catch</span> (error) {</span><br><span class="line">      <span class="keyword">return</span> reject(error)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="comment">// 如果都不是, 直接 resolve result</span></span><br><span class="line">  resolve(result);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* promise 的 catch 方法 */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* promise 的 race 方法 */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.race = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promise.length; i++) {</span><br><span class="line">      promises[i].then(resolve, reject)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* promise 的 all 方法 */</span></span><br><span class="line"><span class="built_in">Promise</span>.prototype.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>{</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>{</span><br><span class="line">    arr[index] = data;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i === promise.length) {</span><br><span class="line">      resolve(arr);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) {</span><br><span class="line">      promises[i].then(<span class="function"><span class="params">data</span> =&gt;</span> {</span><br><span class="line">        processData(i, data)</span><br><span class="line">      }, reject)</span><br><span class="line">    }</span><br><span class="line">  })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h4 id="简化版实现-Promise"><a href="#简化版实现-Promise" class="headerlink" title="简化版实现 Promise"></a>简化版实现 Promise</h4><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">excutor</span>) </span>{</span><br><span class="line">  <span class="comment">// 事件池, Promise resolve 时的回调函数集合</span></span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallback = [];</span><br><span class="line">  <span class="comment">// excutor: new Promise 时传入的函数</span></span><br><span class="line">  excutor(<span class="function"><span class="params">value</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">this</span>.data = value;</span><br><span class="line">      <span class="keyword">this</span>.onResolvedCallback.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(value));</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> {</span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallback.push(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">      <span class="keyword">const</span> result = onResolved(<span class="keyword">this</span>.data);</span><br><span class="line">      result <span class="keyword">instanceof</span> <span class="built_in">Promise</span> ? result.then(resolve) : resolve(result);</span><br><span class="line">    })</span><br><span class="line">  })</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> { resolve(<span class="number">1</span>) }, <span class="number">500</span>)</span><br><span class="line">})</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> {</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> { resolve(<span class="number">2</span>) }, <span class="number">500</span>)</span><br><span class="line">})</span><br><span class="line">.then(<span class="built_in">console</span>.log(<span class="string">'last'</span>))</span><br></pre></td></tr></tbody></table></figure>

<h3 id="宏任务-amp-微任务"><a href="#宏任务-amp-微任务" class="headerlink" title="宏任务 &amp; 微任务"></a>宏任务 &amp; 微任务</h3><p>等待任务队列中的异步任务的处理机制</p>
<ul>
<li>浏览器的任务队列<ul>
<li>主任务队列: 存储的都是同步任务</li>
<li>等待任务队列: 存储的都是异步任务<blockquote>
<p>首先浏览器会把主任务队列中的同步任务全部执行完后, 再去等待任务队列中看哪个任务达到执行条件了, 把达到执行条件的任务放到主任务队列中去执行, 等这些任务执行完后再去等待任务队列中看哪个任务达到执行条件, 再把达到执行条件的任务放到主任吴队列中执行… 如此循环, 这种循环叫做「<strong><em>事件循环（Event loop）: JS 执行机制</em></strong>」</p>
</blockquote>
</li>
</ul>
</li>
<li>微任务<ul>
<li>Promise 的 then 回调函数</li>
<li>async 函数中 await 下面的代码</li>
<li>process.nextTick</li>
</ul>
</li>
<li>宏任务<ul>
<li>定时器（setInterval / setTimeout）<blockquote>
<p>异步任务执行的规则是看谁先达到执行条件, 但是谁先到达执行条件也有优先级的问题, 这个优先级要看这个任务是宏任务还是微任务; <strong>微任务的优先级比宏任务的优先级要高</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>当主任务队列中同步任务执行完, 先去等待任务队列中把所有的微任务找到并且执行这些微任务, 等微任务执行完再去把宏任务找出来并且执行</p>
</blockquote>
<h3 id="async-amp-await"><a href="#async-amp-await" class="headerlink" title="async &amp; await"></a>async &amp; await</h3><p>ES6新增的关键字, 用于把异步变同步「真实项目中常结合 AJAX 和 Promise 一起使用」</p>
<ul>
<li>async 在函数定义时使用, 用 async 定义的函数默认返回一个 Promise 实例, 可以直接 .then</li>
<li>await（要和 async 一起使用）<ol>
<li>如果 await 右侧是同步的代码, 就会让同步代码执行; 如果执行的是一个函数, 还会把这个函数的返回值给到 await 左边的变量（相当于 await 的返回值）</li>
<li>如果 await 右侧是一个 Promise 实例, 或者一个方法返回了 Promise 实例, await 会等着 Promise 的实例 resolve, 并且在实例 resolve 之前, await 后面的代码不执行; 还会拿到 Promise 在 resolve 时传入的值并且赋值给等号左侧变量（相当于 await 的返回值）</li>
<li>await 会把 await 下面的代码变成微任务<blockquote>
<p>await 有返回值, 如果右边是一个值, 就把这个值返回; 如果是 Promise, 获取 Promise resolve 时传递的数据; await 等待, 等它右侧的代码执行完; 后面经常跟一个 Promise 实例或者跟返回 Promise 实例的方法</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="DOM-事件"><a href="#DOM-事件" class="headerlink" title="DOM 事件"></a>DOM 事件</h2><p>事件（一个时刻）: 文档（html 元素 &amp; document）/浏览器窗口发生的一些特定的交互瞬间; 一般给事件绑定一个事件监听函数来监听这些事件, 以实现在事件发生时执行特定（需要）的操作</p>
<h3 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h3><ol>
<li><strong>鼠标事件</strong><ul>
<li>onclick 单击</li>
<li>ondblclick 双击</li>
<li>onmouseover 鼠标划入</li>
<li>onmouseout 鼠标划出</li>
<li>onmouseenter 鼠标进入</li>
<li>onmouseleave 鼠标离开</li>
<li>onmousedown 鼠标左键按下「可以做拖拽」</li>
<li>onmouseup 鼠标左键抬起「可以做拖拽」</li>
<li>onmousemove 鼠标移动</li>
<li>onmousewheel 鼠标滚轮滚动</li>
<li>oncontextmenu 鼠标右键「右键弹出自定义菜单」<blockquote>
<p>「enter / over 的区别」</p>
<ul>
<li>enter: 从父元素进入子元素不会触发父元素的离开事件, 接着触发子元素的 enter 事件, 不会冒泡所以父元素的 enter 事件不会触发</li>
<li>over: 从父元素进入子元素会触发父元素的离开事件, 接着触发子元素的 over 事件, 因为冒泡又会触发父元素的 over 事件</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><strong>键盘事件</strong><ul>
<li>onkeydown 键盘按键按下</li>
<li>onkeyup 键盘按键弹起</li>
<li>onkeypress 按键「有兼容性问题」<blockquote>
<p>一般表单元素、document、documentElement、document.body、window 需要绑定键盘事件, 其他标签一般不需要键盘事件</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>表单元素事件</strong><ul>
<li>onfocus 得焦</li>
<li>onblur 失焦</li>
<li>oninput 输入</li>
<li>onchange 表单的值发生改变</li>
<li>onsubmit 表单提交</li>
</ul>
</li>
<li><strong>系统事件</strong><ul>
<li>window.onload 页面中所有的资源全部加载完成后触发</li>
<li>window.onresize 浏览器窗口的尺寸发生改变时触发</li>
<li>window.onscroll 浏览器窗口的滚动条滚动的时候触发<blockquote>
<p>window.onload: 页面中所有的资源全部加载完成后才会触发; DOMContentLoaded (DOM2级事件): ⻚面的 DOM 结构加载并解析完成就会触发, 用法: <code>document.addEventListener('DOMContentLoaded', callback)</code>「DOMContentLoaded 触发早于 window.onload」</p>
</blockquote>
</li>
</ul>
</li>
<li><strong>移动端事件</strong><ul>
<li>ontouchstart 触摸屏幕元素时触发</li>
<li>ontouchend 离开屏幕时触发</li>
<li>ontouchmove 滑动屏幕时触发<blockquote>
<p>其他特殊能力需要看操作系统是否给了浏览器权限, 还要看浏览器的开发商是否开发相应功能去调用这个操作系统的能力; 「移动端使用 onclick 会有 300ms 延迟」</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>事件触发时, 浏览器执行事件函数并传入的一个特殊的实参, 这个实参是一个对象, 对象中保存了事件触发时的有效信息</p>
<ul>
<li>鼠标事件对象（MouseEvent）<ul>
<li>target 事件源（触发事件的元素对象）</li>
<li>clientX 鼠标点击的位置相对于浏览器可视窗口左边的水平坐标</li>
<li>clientY 鼠标点击的位置相对于浏览器可视窗口上边的垂直坐标</li>
<li>pageX 鼠标点击的位置相对于⻚面左边缘的水平坐标(包含滚出的距离)</li>
<li>pageY 鼠标点击的位置相对于⻚面上边缘的垂直坐标(包含滚出的距离)</li>
</ul>
</li>
<li>键盘事件对象（KeyboardEvent）<ul>
<li>keyCode 键盘上的键对应的键码（是一个数字）</li>
</ul>
</li>
</ul>
<h3 id="默认事件和默认行为"><a href="#默认事件和默认行为" class="headerlink" title="默认事件和默认行为"></a>默认事件和默认行为</h3><ul>
<li>默认事件: 如没有给a标签绑定过事件但点击它却有反应</li>
<li>默认行为: 如a标签跳转到href指定链接的功能、鼠标右键点击出现一个菜单等<ul>
<li>阻止默认行为: <ul>
<li>event.preventDefault()「IE不兼容」</li>
<li>return false「通用」</li>
</ul>
</li>
<li>IE阻止默认行为: <ul>
<li>event.returnValue = false</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="事件传播机制"><a href="#事件传播机制" class="headerlink" title="事件传播机制"></a>事件传播机制</h3><p>事件冒泡: 触发某个元素的某个事件, 该元素的父级元素以及整个文档顶端的 document 的该事件都会被依次触发; 这种从低层级的 html 元素向高层级依次触发事件的现象称为事件的冒泡机制「<code>元素.onXXX = function() {}</code> 绑定的事件都是 DOM0 级事件, DOM0 级事件都是绑定在冒泡阶段的」</p>
<blockquote>
<p>事件触发三阶段（事件流）: 捕获阶段、目标阶段、冒泡阶段; 从最为外层元素找到事件源的过程称为捕获阶段, 在捕获的过程中, 如果经过的元素有绑定带有该事件, 也会被触发, 在事件⽬标(事件源 - 触发事件的元素对象 - event.target)点击触发后, 开始向上冒泡, 依次触发父级元素的该事件</p>
</blockquote>
<ul>
<li>取消冒泡: event.stopPropagation() 阻止事件冒泡</li>
<li>IE取消冒泡: event.cancelBubble = true<blockquote>
<p>取消冒泡后, 事件不会再向上传播, 更高层级的元素对应事件不会触发</p>
</blockquote>
</li>
</ul>
<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>当遇到对一个元素中所有的子元素绑定相同的事件, 并且事件触发时做的事情⼀样, 利用事件的冒泡机制, 把事件绑定给父元素(一般绑定给父元素, 也可以绑定给更高的元素), 然后根据事件触发时事件源e.target判断点击的到底是哪个元素</p>
<p>事件委托的优点</p>
<ul>
<li>性能比循环事件绑定好</li>
<li>动态添加的元素也可以有效果</li>
</ul>
<h3 id="DOM0-DOM2级事件"><a href="#DOM0-DOM2级事件" class="headerlink" title="DOM0/DOM2级事件"></a>DOM0/DOM2级事件</h3><p><strong>DOM0（1）级事件「绑定在冒泡阶段」</strong></p>
<ul>
<li><code>元素对象.onXXX = function() {}</code> 通过给元素对象的事件属性赋值一个函数实现这个事件的监听, 当事件触发时, 浏览器就会把这个监听函数执行</li>
<li>DOM0 级事件解绑事件监听函数: 把对象的事件属性赋值为 null</li>
<li>DOM0 级事件不能同时给一个事件绑定多个监听函数, 因为 DOM0 级事件是给对象的事件属性赋值, 一个属性只能保存一个值, 多次赋值属性代表的是最后一个值</li>
</ul>
<p><strong>DOM2级事件「可以选择绑定在捕获/冒泡阶段」</strong></p>
<ul>
<li><code>元素对象.addEventListener('不带 on 的事件名', 事件函数, 是否为捕获阶段)</code> 不带 on 的事件名: click、mouseover…; 事件函数: 事件触发时执行的函数; 是否为捕获阶段: false 捕获阶段、true 冒泡阶段</li>
<li>DOM2 级事件解绑事件监听函数: <code>元素对象.removeEventlisetener('不带 on 的事件名', 事件函数', 是否为捕获阶段)</code></li>
<li>DOM2 级事件可以给同一个元素的同一个事件绑定多个事件监听函数（但不能重复绑定同一个监听函数）, 并且在事件触发的时候会按照绑定顺序以此触发</li>
<li>标准浏览器的 DOM2 级事件可以绑定多个事件监听函数的原理: DOM2 级事件给每个元素的每个事件都设置了一个事件池, 类似于一个数组, 每次 addEventListener 都是把事件监听函数加入到事件池中(把事件监听函数放到事件池中并不会立即执行), 等事件触发时, 再从事件池中把事件监听函数按顺序拿出来一个一个执行</li>
<li>IE DOM2级事件处理方法: <code>元素对象.attachjEvent(带 on 的事件名, 事件函数)</code> <code>元素对象.detachEvent(带 on 的事件名, 事件函数)</code></li>
</ul>
<p><strong>DOM0和DOM2事件的区别</strong></p>
<ul>
<li>DOM0 事件绑定是给元素的事件属性赋值, ⼀个属性只能对应一个值, 所以不能给同一个事件绑定多个监听函数; 而 DOM2 有事件池, 所以可以绑定多个</li>
<li>DOM0 只能绑定在冒泡阶段; 而 DOM2 可以选择绑定在冒泡阶段还是捕获阶段</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1966861494@qq.com">Edsyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m3/">http://blog.lagerstroemia.com.cn/2020/02/17/js/mount/m3/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lagerstroemia.com.cn" target="_blank">Edsyang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/02/17/js/mount/m4/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">M4: 设计模式</div></div></a></div><div class="next-post pull_right"><a href="/2020/02/17/js/mount/m2/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">M2: 面向对象(OOP)</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WgFk4Onl7sisfXpq9vHcehGJ-gzGzoHsz',
  appKey: '3DLR7iLY5al5dbIdo9kWnDHU',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Edsyang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19038398号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>