<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Webpack Basic | Edsyang</title><meta name="description" content="Webpack 中文网 | Webpack 配置选项 概念webpack 是一个 JavaScript 应用程序的静态模块打包器(module bundler), 处理时会递归构建一个依赖关系图(dependency graph), 包含程序需要的每个模块, 然后将这些模块打包成一个或多个 bundle  从 webpack v4.0.0 开始, 可以不用引入一个配置文件; 然而, webpack"><meta name="keywords" content="Personal blog about font-end technology &amp; record others"><meta name="author" content="Edsyang,edsyang1102@gmail.com"><meta name="copyright" content="Edsyang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Webpack Basic"><meta name="twitter:description" content="Webpack 中文网 | Webpack 配置选项 概念webpack 是一个 JavaScript 应用程序的静态模块打包器(module bundler), 处理时会递归构建一个依赖关系图(dependency graph), 包含程序需要的每个模块, 然后将这些模块打包成一个或多个 bundle  从 webpack v4.0.0 开始, 可以不用引入一个配置文件; 然而, webpack"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Webpack Basic"><meta property="og:url" content="http://blog.lagerstroemia.com.cn/2019/11/26/webpack/webpack-basic/"><meta property="og:site_name" content="Edsyang"><meta property="og:description" content="Webpack 中文网 | Webpack 配置选项 概念webpack 是一个 JavaScript 应用程序的静态模块打包器(module bundler), 处理时会递归构建一个依赖关系图(dependency graph), 包含程序需要的每个模块, 然后将这些模块打包成一个或多个 bundle  从 webpack v4.0.0 开始, 可以不用引入一个配置文件; 然而, webpack"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-11-26T09:58:53.878Z"><meta property="article:modified_time" content="2020-05-03T03:15:34.585Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.lagerstroemia.com.cn/2019/11/26/webpack/webpack-basic/"><link rel="prev" title="为什么要使用 TS ?" href="http://blog.lagerstroemia.com.cn/2019/11/26/ts/why/"><link rel="next" title="Docker" href="http://blog.lagerstroemia.com.cn/2019/11/26/server/operation/docker/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Edsyang","link":"链接: ","source":"来源: Edsyang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Edsyang" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">124</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">44</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#入口起点-Entry-Points"><span class="toc-number">2.</span> <span class="toc-text">入口起点(Entry Points)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单个入口-简写-语法"><span class="toc-number">2.1.</span> <span class="toc-text">单个入口(简写)语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象语法"><span class="toc-number">2.2.</span> <span class="toc-text">对象语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见场景"><span class="toc-number">2.3.</span> <span class="toc-text">常见场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分离-应用程序-app-和第三方库-vendor-入口"><span class="toc-number">2.3.1.</span> <span class="toc-text">分离 应用程序(app)和第三方库(vendor)入口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多页面应用程序"><span class="toc-number">2.3.2.</span> <span class="toc-text">多页面应用程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出-Output"><span class="toc-number">3.</span> <span class="toc-text">输出(Output)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#output-用法"><span class="toc-number">3.1.</span> <span class="toc-text">output 用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个入口起点"><span class="toc-number">3.2.</span> <span class="toc-text">多个入口起点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高级进阶"><span class="toc-number">3.3.</span> <span class="toc-text">高级进阶</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模式-Model"><span class="toc-number">4.</span> <span class="toc-text">模式(Model)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#model-用法"><span class="toc-number">4.1.</span> <span class="toc-text">model 用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mode-developement"><span class="toc-number">4.2.</span> <span class="toc-text">mode: developement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mode-production"><span class="toc-number">4.3.</span> <span class="toc-text">mode: production</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Loader"><span class="toc-number">5.</span> <span class="toc-text">Loader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用-loader"><span class="toc-number">5.1.</span> <span class="toc-text">使用 loader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置"><span class="toc-number">5.1.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内联"><span class="toc-number">5.1.2.</span> <span class="toc-text">内联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CLI"><span class="toc-number">5.1.3.</span> <span class="toc-text">CLI</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#loader-特性"><span class="toc-number">5.2.</span> <span class="toc-text">loader 特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-loader"><span class="toc-number">5.3.</span> <span class="toc-text">解析 loader</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插件-Plugins"><span class="toc-number">6.</span> <span class="toc-text">插件(Plugins)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#剖析"><span class="toc-number">6.1.</span> <span class="toc-text">剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#plugins-用法"><span class="toc-number">6.2.</span> <span class="toc-text">plugins 用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置-1"><span class="toc-number">6.2.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-API"><span class="toc-number">6.2.2.</span> <span class="toc-text">Node API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#配置-Configuration"><span class="toc-number">7.</span> <span class="toc-text">配置(Configuration)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本配置"><span class="toc-number">7.1.</span> <span class="toc-text">基本配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多个-Target"><span class="toc-number">7.2.</span> <span class="toc-text">多个 Target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用其他配置语言"><span class="toc-number">7.3.</span> <span class="toc-text">使用其他配置语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块-Modules"><span class="toc-number">8.</span> <span class="toc-text">模块(Modules)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-webpack-模块"><span class="toc-number">8.1.</span> <span class="toc-text">什么是 webpack 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#支持的模块类型"><span class="toc-number">8.2.</span> <span class="toc-text">支持的模块类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块解析-Module-Resolution"><span class="toc-number">9.</span> <span class="toc-text">模块解析(Module Resolution)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#webpack-中的解析规则"><span class="toc-number">9.1.</span> <span class="toc-text">webpack 中的解析规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#绝对路径"><span class="toc-number">9.1.1.</span> <span class="toc-text">绝对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#相对路径"><span class="toc-number">9.1.2.</span> <span class="toc-text">相对路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块路径"><span class="toc-number">9.1.3.</span> <span class="toc-text">模块路径</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解析-Loader"><span class="toc-number">9.2.</span> <span class="toc-text">解析 Loader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存"><span class="toc-number">9.3.</span> <span class="toc-text">缓存</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖图-Dependency-Graph"><span class="toc-number">10.</span> <span class="toc-text">依赖图(Dependency Graph)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mainfest"><span class="toc-number">11.</span> <span class="toc-text">Mainfest</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建目标-Targets"><span class="toc-number">12.</span> <span class="toc-text">构建目标(Targets)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模块热替换-Hot-Module-Replacement"><span class="toc-number">13.</span> <span class="toc-text">模块热替换(Hot Module Replacement)</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Edsyang</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Webpack Basic</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-11-26 09:58:53"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-11-26</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-03 03:15:34"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-03</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Webpack/">Webpack</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.9k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 17 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><a href="https://www.webpackjs.com/" target="_blank" rel="noopener">Webpack 中文网</a> | <a href="https://www.webpackjs.com/configuration/#%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">Webpack 配置选项</a></p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>webpack 是一个 JavaScript 应用程序的<strong>静态模块打包器(module bundler)</strong>, 处理时会递归构建一个依赖关系图(dependency graph), 包含程序需要的每个模块, 然后将这些模块打包成一个或多个 bundle</p>
<blockquote>
<p>从 webpack v4.0.0 开始, 可以不用引入一个配置文件; 然而, webpack 仍然还是<a href="https://www.webpackjs.com/configuration/" target="_blank" rel="noopener">高度可配置的</a></p>
</blockquote>
<p>四个核心概念:</p>
<ol>
<li>入口</li>
<li>输出</li>
<li>loader</li>
<li>插件</li>
</ol>
<ul>
<li><p>入口(entry)</p>
<p>入口起点(entry point) 指示 webpack 应该是用哪个模块作为构建其内部依赖图的开始; 进入入口起点后, webpack 会找出有哪些模块和库是入口起点(直接和间接)依赖的</p>
<p>每个依赖项随即被处理, 最后输出到称为 bundles 的文件中</p>
<p>可以通过在 webpack 配置 entry 属性来指定一个/多个入口起点, 默认值是 <code>./src</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>出口(output)</p>
<p>output 属性告诉 webpack 在哪里输出它所创建的 bundle, 以及如何命名这些文件, 默认值为 <code>./dist</code>; 基本上, 整个应用程序结构, 都会被编译到指定的输出路径的文件夹中; 可以通过在配置中指定一个 output 字段, 来配置这些处理过程</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 想要 bundle 生成(emit) 到哪里</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 告诉 webpack bundle 名称</span></span><br><span class="line">    filename: <span class="string">'hello-webpack.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>生成(emitted 或 emit)</strong> 是 “生产(produced)” 或 “释放(discharged)” 的特殊语句</p>
</blockquote>
</li>
<li><p>loader</p>
<p>因为 webpack 本身只能理解 JavaScript, 所以 loader 能让 webpack 能够处理那些非 JavaScript 文件(将所有类型的文件转换为 webpack 能够处理的有效模块) —— 用于转换某些类型的模块</p>
<p>本质上, webpack loader 将所有类型的文件, 转换为应用程序的依赖图(和最终的 bundle) 可以直接引用的模块</p>
<blockquote>
<p>注意: loader 能够 <code>import</code> 导入任何类型的模块(如 <code>.css</code> 文件), 这是 webpack 特有的功能, 其他打包程序或任务执行器的可能并不支持</p>
</blockquote>
<p>在 webpack 的配置中 loader 有两个目标</p>
<ol>
<li><code>test</code> 属性: 用于标识出应该被对应的 loader 进行转换的某个或某些文件</li>
<li><code>use</code> 属性: 表示进行转换时，应该使用哪个 loader<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'hello-webpack.bundle.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 对一个单独的 module 对象定义了 rules 属性</span></span><br><span class="line">    <span class="comment">// 里面包含两个必须的属性: test 和 use</span></span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// 在 require / import 语句中被解析为 .txt 的路径时</span></span><br><span class="line">      <span class="comment">// 在对它打包之前, 先使用 raw-loader 转换一下</span></span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules。然而，在定义错误时 webpack 会给出严重的警告。为了使你受益于此，如果没有按照正确方式去做，webpack 会“给出严重的警告”</p>
</blockquote>
</li>
</ol>
</li>
<li><p>插件(plugins)</p>
<p>loader 用于转换某些类型的模块, 而插件则可以用于执行范围更广的任务</p>
<p>插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量; 插件接口功能强大, 可以用开处理各种任务</p>
<p>使用一个插件, 只需要 <code>require()</code> 它, 然后把它添加到 <code>plugins</code> 数组中; 多数插件可以通过选项(option)自定义; 也可以在一个配置文件中因为不同目的而多次使用同一个插件, 这是需要通过使用 <code>new</code> 操作符来创建它的一个实例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 用于访问内置插件</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.txt$/</span>, <span class="attr">use</span>: <span class="string">'raw-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.webpackjs.com/plugins/" target="_blank" rel="noopener">插件列表</a></p>
</li>
<li><p>模式</p>
<p>通过选择 <code>development</code> 或 <code>production</code> 之中的一个，来设置 <code>mode</code> 参数，你可以启用相应模式下的 webpack 内置的优化</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="入口起点-Entry-Points"><a href="#入口起点-Entry-Points" class="headerlink" title="入口起点(Entry Points)"></a>入口起点(Entry Points)</h2><p>webpack 配置中有多种定义 entry 属性</p>
<h3 id="单个入口-简写-语法"><a href="#单个入口-简写-语法" class="headerlink" title="单个入口(简写)语法"></a>单个入口(简写)语法</h3><p>用法: <code>entry: string|Array&lt;string&gt;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个入口语法简写</span></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意: 适用于 只有一个入口起点的应用程序或工具(即 library), 但该语法在扩展配置时有失灵活性</p>
</blockquote>
<blockquote>
<p><strong>向 <code>entry</code> 传入一个数组时会发生什么?</strong></p>
<p>向 <code>entry</code> 属性传入 「文件路径(file path)数组」 将创建 “多个主入口(multi-main entry)”; 在你想要多个依赖文件一起注入, 并且将它们的依赖导向(graph)到一个 “chunk” 时, 传入数组的方式就很有用</p>
</blockquote>
<h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><p>用法: <code>entry: {[entryChunkName: string]: string|Array&lt;string&gt;}</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对象语法会比较繁琐, 但是, 这是应用程序中定义入口的最可扩展的方式</p>
<blockquote>
<p><strong>“可扩展的 webpack 配置”</strong>是指可重用且可以和其他配置组合使用; 这是一种流行的技术, 将用于关注点(concern)从环境(environment)、构建目标(build target)、运行时(runtime)中分离, 然后使用专门的工具(如 webpack-merge)将它们合并</p>
</blockquote>
<h3 id="常见场景"><a href="#常见场景" class="headerlink" title="常见场景"></a>常见场景</h3><h4 id="分离-应用程序-app-和第三方库-vendor-入口"><a href="#分离-应用程序-app-和第三方库-vendor-入口" class="headerlink" title="分离 应用程序(app)和第三方库(vendor)入口"></a>分离 应用程序(app)和第三方库(vendor)入口</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这是什么?</strong></p>
<ul>
<li>表面上看是告诉我们 webpack 从 <code>app.js</code> 和 <code>vendors.js</code> 开始构建依赖图, 这些依赖图是彼此完全分离、互相独立的(每个 bundle 中都有一个 webpack 引导); 这种方式比较常见于<strong>只有一个入口起点(不包括 vendor) 的但页面应用中</strong></li>
</ul>
<p><strong>为什么?</strong></p>
<ul>
<li>该设置允许使用 <code>CommonsChunkPlugin</code> 从 应用程序 bundle 中提取 vendor 引用到 vendor bundle, 并把引用 vendor 的部分替换为 <code>__webpack_require__()</code> 调用; 如果应用程序 bundle 中没有 vendor 代码, 那么可以在 webpack 中实现被称为<a href="https://www.webpackjs.com/guides/caching/" target="_blank" rel="noopener">长效缓存</a>的通用模式</li>
</ul>
<h4 id="多页面应用程序"><a href="#多页面应用程序" class="headerlink" title="多页面应用程序"></a>多页面应用程序</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: <span class="string">'./src/pageOne/index.js'</span>,</span><br><span class="line">    pageTwo: <span class="string">'./src/pageTwo/index.js'</span>,</span><br><span class="line">    pageThree: <span class="string">'./src/pageThree/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>这是什么?</strong></p>
<ul>
<li>告诉 webpack 需要3个独立分离的依赖图</li>
</ul>
<p><strong>为什么?</strong></p>
<ul>
<li>在多页面应用中, 每当页面跳转时服务器将获取一个新的 HTML 文档, 页面重新加载新文档, 且资源被重新下载, 可以利用这个机制多很多事<ul>
<li>使用 <code>CommonsChunkPlugin</code> 为每个页面间的应用程序共享代码创建 bundle; 由于入口起点增多, 多页面应用能够复用入口起点间的大量代码/模块, 从而可以从这些技术中受益</li>
</ul>
</li>
</ul>
<blockquote>
<p>每个 HTML 文档只使用一个入口起点</p>
</blockquote>
<h2 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出(Output)"></a>输出(Output)</h2><p>配置 <code>output</code> 选项可以控制 webpack 如何向硬盘写入编译文件</p>
<blockquote>
<p>注意: 即使可以存在多个入口起点, 但只能有一个输出配置</p>
</blockquote>
<h3 id="output-用法"><a href="#output-用法" class="headerlink" title="output 用法"></a>output 用法</h3><p>在 webpack 中配置 <code>output</code> 属性的最低要求是, 将它的值设置为一个对象, 包括以下两点</p>
<ol>
<li><code>filename</code>: 用于输出文件的文件名</li>
<li><code>path</code>: 目标输出目录 <code>path</code> 的绝对路径<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  <span class="comment">// 将一个单独的 bundle.js 文件输出到 /home/proj/public/assets 目录中</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/assets'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="多个入口起点"><a href="#多个入口起点" class="headerlink" title="多个入口起点"></a>多个入口起点</h3><p>如果设置创建了多个 “chunk”(例如: 使用多个入口起点或使用像 ComminsChunkPlugin 这样的插件), 则使用占位符来确保每个文件具有唯一的名称</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 写入到硬盘 ./dist/app.js ./dist/search.js</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'./dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">"/home/proj/cdn/assets/[hash]"</span>,</span><br><span class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在编译时不知道最终输出文件的 publicPath 的情况下, publicPath 可以留空, 并且在入口起点文件运行时动态设置; 如果你在编译时不知道 publicPath, 你可以先忽略它, 并且在入口起点设置 <code>__webpack_public_path__</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br><span class="line"><span class="comment">// 剩余的应用程序入口</span></span><br></pre></td></tr></table></figure>

<h2 id="模式-Model"><a href="#模式-Model" class="headerlink" title="模式(Model)"></a>模式(Model)</h2><p>提供 <code>mode</code> 配置选项, 告诉 webpack 使用相应模式的内置优化</p>
<h3 id="model-用法"><a href="#model-用法" class="headerlink" title="model 用法"></a>model 用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只在配置中提供 `mode` 选项</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 从 CLI 参数中传递</span></span><br><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure>
<p>支持以下字符串值</p>
<ul>
<li><code>developement</code>: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>developement</code>; 启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></li>
<li><code>production</code>: 会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>; 启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code><blockquote>
<p>注意: 只设置 <code>NODE_ENV</code>, 则不会自动设置 <code>mode</code></p>
</blockquote>
</li>
</ul>
<h3 id="mode-developement"><a href="#mode-developement" class="headerlink" title="mode: developement"></a>mode: developement</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.developement.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mode-production"><a href="#mode-production" class="headerlink" title="mode: production"></a>mode: production</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.production.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+  mode: <span class="string">'production'</span>,</span><br><span class="line">-  plugins: [</span><br><span class="line">-    <span class="keyword">new</span> UglifyJsPlugin(<span class="comment">/* ... */</span>),</span><br><span class="line">-    <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"production"</span>) &#125;),</span><br><span class="line">-    <span class="keyword">new</span> webpack.optimize.ModuleConcatenationPlugin(),</span><br><span class="line">-    <span class="keyword">new</span> webpack.NoEmitOnErrorsPlugin()</span><br><span class="line">-  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>loader 用于对模块的源代码进行转换, 可以在 <code>import</code> 或 “加载”模块是预处理文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 loader 告诉 webpack 加载 css 文件或者将 typescript 转为 JavaScript</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先安装 loader</span></span><br><span class="line">npm install --save-dev css-loader ts-loader</span><br><span class="line"><span class="comment">// 然后指示 webpack 对每个 .css 使用 css-loader, 对 .ts 使用 ts-loader</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, <span class="attr">use</span>: <span class="string">'css-loader'</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">test</span>: <span class="regexp">/\.ts$/</span>, <span class="attr">use</span>: <span class="string">'ts-loader'</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-loader"><a href="#使用-loader" class="headerlink" title="使用 loader"></a>使用 loader</h3><p>三种使用 loader 的方式:</p>
<ul>
<li>配置(推荐): 在 <code>webpack.config.js</code> 文件中指定 loader</li>
<li>内联: 在每个 <code>import</code> 语句中显式指定 loader</li>
<li>CLI: 在 shell 命令中指定它们</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><code>module.rules</code> 允许在 webpack 配置中指定多个 loader; 简明展示 loader, 有助于代码变得简洁, 同时可以对各个 loader 有个全局概述</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        &#123; <span class="attr">loader</span>: <span class="string">'style-loader'</span> &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            modules: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h4><p>可以在 <code>import</code> 语句或任何等效于 “import” 的方式中指定 loader, 使用 <code>!</code> 将资源中的 loader 分开, 分开的每个部分都相对于当前目录解析</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Styles <span class="keyword">from</span> <span class="string">'style-loader!css-loader?modules!./styles.css'</span>;</span><br></pre></td></tr></table></figure>
<p>通过前置所有规则及使用 <code>!</code>, 可以对应覆盖到配置中的任意 loader</p>
<p>选项可以传递查询参数, 例如 <code>?key=value&amp;foo=bar</code>, 或者一个 JSON 对象, 例如 <code>?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}</code></p>
<blockquote>
<p>尽可能使用 <code>module.rules</code>, 因为这样可以减少源码中的代码量, 并且可以在出错时, 更快地调试和定位 loader 中的问题</p>
</blockquote>
<h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对 .jade 文件使用 jade-loader</span></span><br><span class="line"><span class="comment">// 对 .css 文件使用 style-loader 和 css-loader</span></span><br><span class="line">webpack --<span class="built_in">module</span>-bind jade-loader --<span class="built_in">module</span>-bind <span class="string">'css=style-loader!css-loader'</span></span><br></pre></td></tr></table></figure>

<h3 id="loader-特性"><a href="#loader-特性" class="headerlink" title="loader 特性"></a>loader 特性</h3><ul>
<li>loader 支持链式传递, 能够对资源使用流水线, 一组链式的 loader 将按照相反的顺序执行, loader 链中的第一个 loader 返回值给下一个 loader, 在最后一个 loader, 返回 webpack 所预期的 JS</li>
<li>loader 可以是同步的, 也可以是异步的</li>
<li>loader 运行在 Node.js 中, 并且能够执行任何可能的操作</li>
<li>loader 接收查询参数, 用于对 loader 传递配置</li>
<li>loader 也能使用 <code>options</code> 对象进行配置</li>
<li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性, 还可以将普通的 npm 模块导出为 loader, 做法是在 <code>package.json</code> 中定义一个 <code>loader</code> 字段</li>
<li>插件(plugin)可以为 loader 带来更多特性</li>
<li>loader 能够产生额外的任意文件</li>
</ul>
<p>loader 通过 (loader) 预处理函数, 为 JS 生态系统提供了更多能力, 用户现在可以更加灵活的引入细粒度逻辑, 例如压缩、打包、语言翻译和其他更多</p>
<h3 id="解析-loader"><a href="#解析-loader" class="headerlink" title="解析 loader"></a>解析 loader</h3><p>loader 遵循标准的模块解析, 多数情况下, loader 将从模块路径(通常将模块路径认为是 <code>npm install</code>、<code>node_modules</code>) 解析</p>
<p>loader 模块需要导出为一个函数, 并且使用 Node.js 兼容的 JS 编写, 通常使用 npm 进行管理, 但是也可以将自定义 loader 作为应用程序中的文件; 按照约定, loader 通常被命名为 <code>xxx-loader</code></p>
<blockquote>
<p><a href="https://www.webpackjs.com/contribute/writing-a-loader/" target="_blank" rel="noopener">如何编写 loader 详情</a></p>
</blockquote>
<h2 id="插件-Plugins"><a href="#插件-Plugins" class="headerlink" title="插件(Plugins)"></a>插件(Plugins)</h2><p>插件是 webpack 支柱功能, 插件的目的在于解决 loader 无法实现的事情</p>
<h3 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h3><p>webpack 插件是一个具有 <code>apply</code> 属性的 JS 对象, <code>apply</code> 属性会被 webpack compiler 调用, 并且 compiler 对象可在整个编译生命周期访问</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// compiler hook 的 tap 方法的第一个参数, 应该是驼峰命名的插件名称</span></span><br><span class="line">    <span class="comment">// 建议为此使用一个常量, 以便它可以在所有的 hook 中复用</span></span><br><span class="line">    compiler.hooks.run.tap(pluginName, compilation =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'webpack 构建过程开始'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="plugins-用法"><a href="#plugins-用法" class="headerlink" title="plugins 用法"></a>plugins 用法</h3><p>由于插件可以携带参数/选项, 所以必须在 webpack 配置中, 向 <code>plugins</code> 属性传入 <code>new</code> 实例</p>
<p>根据 webpack 用法, 使用不同方式的插件</p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>); <span class="comment">// 通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 访问内置插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;<span class="attr">template</span>: <span class="string">'./src/index.html'</span>&#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config;</span><br></pre></td></tr></table></figure>

<h4 id="Node-API"><a href="#Node-API" class="headerlink" title="Node API"></a>Node API</h4><blockquote>
<p>注: 即使使用 Node API, 用户也应该在配置中传入 <code>plugins</code> 属性, <code>compiler.apply</code> 并不是推荐的使用方式</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>); <span class="comment">// 访问 webpack 运行时(runtime)</span></span><br><span class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compiler = webpack(configuration);</span><br><span class="line">compiler.apply(<span class="keyword">new</span> webpack.ProgressPlugin());</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上代码和 webpack 自身运行时(runtime) 极其类似, <a href="https://github.com/webpack/webpack" target="_blank" rel="noopener">webpack 源码</a>中隐藏有大量使用示例, 可以用在自己的配置和脚本中</p>
</blockquote>
<h2 id="配置-Configuration"><a href="#配置-Configuration" class="headerlink" title="配置(Configuration)"></a>配置(Configuration)</h2><p><strong>webpack 的配置文件, 是导出一个对象的 JavaScript 文件</strong></p>
<p>因为 webpack 配置是标准的 Node.js CommonJS 模块, 可以做到以下事情</p>
<ul>
<li>通过 <code>require()</code> 导入其他文件</li>
<li>通过 <code>require()</code> 使用 npm 的工具函数</li>
<li>使用 JavaScript 控制流表达式, 例如 <code>?:</code> 操作符</li>
<li>对常用值使用常量或变量</li>
<li>编写并执行函数来生成部分配置</li>
</ul>
<p>应该避免以下做法</p>
<ul>
<li>在使用 webpack 命令行接口(CLI) (应该编写自己的命令行接口(CLI), 或使用 <code>--env</code>) 时, 访问命令行接口(CLI) 参数</li>
<li>导出不确定的值(调用 webpack 两次应该产生同样的输出文件)</li>
<li>编写很长的配置(应该将配置拆分为多个文件)</li>
</ul>
<blockquote>
<p>webpack 的配置有很多种格式和风格, 但是为了易于理解和维护, 应该始终采用同一种用法、格式和风格</p>
</blockquote>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'developement'</span>,</span><br><span class="line">  entry: <span class="string">'./foo.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    filename: <span class="string">'foo.bundle.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="多个-Target"><a href="#多个-Target" class="headerlink" title="多个 Target"></a>多个 Target</h3><p><a href="https://www.webpackjs.com/configuration/configuration-types/#exporting-multiple-configurations" target="_blank" rel="noopener">导出多个配置</a></p>
<h3 id="使用其他配置语言"><a href="#使用其他配置语言" class="headerlink" title="使用其他配置语言"></a>使用其他配置语言</h3><p><a href="https://www.webpackjs.com/configuration/configuration-languages/" target="_blank" rel="noopener">配置语言</a></p>
<h2 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h2><p>在模块化编程中, 开发者将程序分解成离散功能块(discrete chunks of functionality), 即模块</p>
<p>每个模块具有相比完整程序更小的接触面, 使得校验、调试、测试相对简单; 静心编写的模块提供了可靠的抽象和封装界限, 使得应用程序中每个模块都具有条理清楚的设计和明确的目的</p>
<h3 id="什么是-webpack-模块"><a href="#什么是-webpack-模块" class="headerlink" title="什么是 webpack 模块"></a>什么是 webpack 模块</h3><p>相较于 Node.js 模块, webpack 模块能够以各种方式表达他们的依赖关系</p>
<ul>
<li>ES2015 <code>import</code> 语句</li>
<li>CommonJS <code>require()</code> 语句</li>
<li>AMD <code>define</code> 和 <code>require</code> 语句</li>
<li>css/sass/less 文件中的 <code>@import</code> 语句</li>
<li>样式(<code>url()</code>) 或 HTML 文件(<code>&lt;img src=...&gt;</code>) 中的图片链接</li>
</ul>
<h3 id="支持的模块类型"><a href="#支持的模块类型" class="headerlink" title="支持的模块类型"></a>支持的模块类型</h3><p>webpack 通过 loader 可以支持各种语言的预处理器编写模块; loader 描述了 webpack 如何处理非 JavaScript 模块, 并在 bundle 中引入这些依赖; webpack 社区已经为各种流行语言和语言处理器构建了 loader, 包括 CoffeeScript、TypeScript、ESNext(Babel)、Sass、Less、Stylus</p>
<p>总的来说, webpack 提供了可定制的、强大和丰富的 API, 允许任何技术栈使用 webpack, 保持了在开发、测试和生产流程中<strong>无侵入性</strong></p>
<p>完整列表参考 <a href="https://www.webpackjs.com/loaders/" target="_blank" rel="noopener">loader 列表</a> 或 <a href="https://www.webpackjs.com/api/loaders/" target="_blank" rel="noopener">自己编写</a></p>
<h2 id="模块解析-Module-Resolution"><a href="#模块解析-Module-Resolution" class="headerlink" title="模块解析(Module Resolution)"></a>模块解析(Module Resolution)</h2><p>resolver 是一个库, 用于帮助找到模块的绝对路径, 一个模块可以作为另一个模块的依赖模块, 然后被后者引用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'path/to/module'</span>;</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'path/to/module'</span>);</span><br></pre></td></tr></table></figure>
<p>所依赖的模块可以是来自应用程序代码或第三方库; resolver 帮助 webpack 找到 bundle 中需要引入的模块代码, 这些代码包含在每个 <code>require / import</code> 语句中; 当打包模块时, webpack 使用 enhanced-resolve 来解析文件路径</p>
<h3 id="webpack-中的解析规则"><a href="#webpack-中的解析规则" class="headerlink" title="webpack 中的解析规则"></a>webpack 中的解析规则</h3><p>使用 <code>enhanced-resolve</code>, webpack 能够解析三种文件路径</p>
<h4 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'/home/me/file'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'C:\\User\\me\\file'</span>;</span><br></pre></td></tr></table></figure>
<p>由于已经取得文件的绝对路径, 因此不需要进一步再做解析</p>
<h4 id="相对路径"><a href="#相对路径" class="headerlink" title="相对路径"></a>相对路径</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'../src/file1'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./file2'</span>;</span><br></pre></td></tr></table></figure>
<p>在这种情况下, 使用 <code>import</code> 或 <code>require</code> 的资源文件所在的目录被认为是上下文目录; 在 <code>import / require</code> 中给定的相对路径, 会添加此上下文路径, 以产生模块的绝对路径</p>
<h4 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'module'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'module/lib/file'</span>;</span><br></pre></td></tr></table></figure>
<p>模块在 <code>resolve.modules</code> 中指定的所有目录内搜索, 可以替换初始模块路径, 此替换路径通过使用 <code>resolve.alias</code> 配置选项来创建一个别名</p>
<p>一旦根据上述规则解析路径后, 解析器(resolver)将检查路径是否指向文件或目录</p>
<p>如果路径指向一个文件:</p>
<ul>
<li>如果路径具有文件扩展名, 则被直接将文件打包</li>
<li>否则将使用 <code>resolve.extensions</code> 选项作为文件扩展名来解析, 此选项告诉解析器在解析中能够接收哪些扩展名(如 <code>.js</code>, <code>.jsx</code>)</li>
</ul>
<p>如果路径指向一个文件夹, 则采取以下步骤找到具有正确扩展名的正确文件</p>
<ul>
<li>如果文件中包含 <code>package.json</code> 文件, 则按顺序查找 <code>resolve.mainFields</code> 配置选项中指定的字段; 并且 <code>package.json</code> 中的第一个这样的字段确定文件路径</li>
<li>如果 <code>package.json</code> 文件不存在或者 <code>package.json</code> 文件中 main 字段没有返回一个有效路径, 则按照顺序查找 <code>resolve.mainFiles</code> 配置选项中指定的文件名, 看是否能在 import / require 目录下匹配到一个存在的文件名</li>
<li>文件扩展名通过 <code>resolve.extensions</code> 选项采用类似的方法进行解析</li>
</ul>
<p>webpack 根据构建目标(build target) 为这些选项提供了合理的默认配置</p>
<h3 id="解析-Loader"><a href="#解析-Loader" class="headerlink" title="解析 Loader"></a>解析 Loader</h3><p>Loader 解析遵循与文件解析器制定的规则相同的规则, 但是 <code>resolveLoader</code> 配置选项可以用来为 Loader 提供独立的解析规则</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>每个文件系统访问都会被缓存, 以便更快触发对同一文件的多个并行或串行请求; 在<a href="https://www.webpackjs.com/configuration/watch/#watch" target="_blank" rel="noopener">观察模式</a>下, 只有修改过的文件会从缓存中摘出, 若果关闭观察模式, 每次编译前清理缓存</p>
<p>更多查看 <a href="https://www.webpackjs.com/configuration/resolve/" target="_blank" rel="noopener">解析 API</a></p>
<h2 id="依赖图-Dependency-Graph"><a href="#依赖图-Dependency-Graph" class="headerlink" title="依赖图(Dependency Graph)"></a>依赖图(Dependency Graph)</h2><p>任何时候, 一个文件依赖于另一个文件, webpack 就把此视为文件之间有依赖关系, 这使得 webpack 可以接受非代码资源, 并且可以把它们作为依赖提供给应用程序</p>
<p>webpack 聪明灵活配置文件中定义一个模块列表开始, 处理应用程序; 从入口起点开始, webpack 递归构建一个依赖图, 这个依赖图包含应用程序所需的每个模块, 然后将所有这些模块大包围少量的 bundle —— 通常只有一个(可由浏览器加载)</p>
<blockquote>
<p>对于 HTTP 1.1 客户端, 由 webpack 打包应用程序会尤其强大, 因为在浏览器发起一个新请求时, 能够减少应用程序必须等待的时间; 对于 HTTP 2, 还可以使用 <strong>代码拆分(code splitting)</strong> 以及通过 webpack 打包来实现<a href="https://medium.com/webpack/webpack-http-2-7083ec3f3ce6#.7y5d3hz59" target="_blank" rel="noopener">最佳优化</a></p>
</blockquote>
<h2 id="Mainfest"><a href="#Mainfest" class="headerlink" title="Mainfest"></a>Mainfest</h2><h2 id="构建目标-Targets"><a href="#构建目标-Targets" class="headerlink" title="构建目标(Targets)"></a>构建目标(Targets)</h2><h2 id="模块热替换-Hot-Module-Replacement"><a href="#模块热替换-Hot-Module-Replacement" class="headerlink" title="模块热替换(Hot Module Replacement)"></a>模块热替换(Hot Module Replacement)</h2></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:edsyang1102@gmail.com">Edsyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lagerstroemia.com.cn/2019/11/26/webpack/webpack-basic/">http://blog.lagerstroemia.com.cn/2019/11/26/webpack/webpack-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lagerstroemia.com.cn" target="_blank">Edsyang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/0081Kckwly1gkrf2rz04kj30m00ffq3z.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/26/ts/why/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">为什么要使用 TS ?</div></div></a></div><div class="next-post pull_right"><a href="/2019/11/26/server/operation/docker/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Docker</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WgFk4Onl7sisfXpq9vHcehGJ-gzGzoHsz',
  appKey: '3DLR7iLY5al5dbIdo9kWnDHU',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By Edsyang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19038398号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>