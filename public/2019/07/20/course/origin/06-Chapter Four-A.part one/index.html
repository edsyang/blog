<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>原生JS - Chapter Four.A | Edsyang</title><meta name="robots" content="noindex"><meta name="description" content="1. 函数的三种角色JS中函数有三种角色：普通函数、构造函数、对象;  普通函数（函数名、形参、实参、返回值）12345function sum (a, b) {  return a + b;} &#x2F;&#x2F; 函数定义var result &#x3D; sum(1, 2); &#x2F;&#x2F; 函数执行console.log(result);  普通函数的执行过程（五步）   构造函数、类（new 构造函数）：必须通过new 调"><meta name="keywords" content="JS Notes"><meta name="author" content="Edsyang,1966861494@qq.com"><meta name="copyright" content="Edsyang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="原生JS - Chapter Four.A"><meta name="twitter:description" content="1. 函数的三种角色JS中函数有三种角色：普通函数、构造函数、对象;  普通函数（函数名、形参、实参、返回值）12345function sum (a, b) {  return a + b;} &#x2F;&#x2F; 函数定义var result &#x3D; sum(1, 2); &#x2F;&#x2F; 函数执行console.log(result);  普通函数的执行过程（五步）   构造函数、类（new 构造函数）：必须通过new 调"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="原生JS - Chapter Four.A"><meta property="og:url" content="http://blog.lagerstroemia.com.cn/2019/07/20/course/origin/06-Chapter%20Four-A.part%20one/"><meta property="og:site_name" content="Edsyang"><meta property="og:description" content="1. 函数的三种角色JS中函数有三种角色：普通函数、构造函数、对象;  普通函数（函数名、形参、实参、返回值）12345function sum (a, b) {  return a + b;} &#x2F;&#x2F; 函数定义var result &#x3D; sum(1, 2); &#x2F;&#x2F; 函数执行console.log(result);  普通函数的执行过程（五步）   构造函数、类（new 构造函数）：必须通过new 调"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-07-20T03:38:34.719Z"><meta property="article:modified_time" content="2020-05-18T16:05:12.070Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.lagerstroemia.com.cn/2019/07/20/course/origin/06-Chapter%20Four-A.part%20one/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Edsyang","link":"链接: ","source":"来源: Edsyang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Edsyang" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">112</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">7</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">37</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-函数的三种角色"><span class="toc-number">1.</span> <span class="toc-text">1. 函数的三种角色</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-call＆apply＆bind"><span class="toc-number">2.</span> <span class="toc-text">2. call＆apply＆bind</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-call＆apply＆bind"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 call＆apply＆bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-求数组极值"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 求数组极值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-sort方法"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 sort方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-假设法"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 假设法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-排序算法"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 排序算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-Math方法（Math-max-和Math-min-）"><span class="toc-number">2.2.4.</span> <span class="toc-text">2.2.4 Math方法（Math.max()和Math.min()）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-5-把数组toString-，然后再eval求值"><span class="toc-number">2.2.5.</span> <span class="toc-text">2.2.5 把数组toString()，然后再eval求值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-数组方法的实现"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 数组方法的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-模拟数组方法"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 模拟数组方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-类数组转数组"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 类数组转数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-类数组转数组的方法"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 类数组转数组的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-类数组转数组方法封装"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 类数组转数组方法封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-try-catch容错处理（异常捕获）"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 try-catch容错处理（异常捕获）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-JS中常见的报错信息"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4 JS中常见的报错信息</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-箭头函数"><span class="toc-number">3.</span> <span class="toc-text">3. 箭头函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-标准函数和箭头函数语法区别"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 标准函数和箭头函数语法区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-简化语法"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 简化语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-sort应用"><span class="toc-number">4.</span> <span class="toc-text">4. sort应用</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Edsyang</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">原生JS - Chapter Four.A</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-07-20 03:38:34"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-18 16:05:12"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-18</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="post-meta__icon fa fa-file-word-o" aria-hidden="true"></i><span>字数总计:</span><span class="word-count">4.7k</span><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-clock-o" aria-hidden="true"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="1-函数的三种角色"><a href="#1-函数的三种角色" class="headerlink" title="1. 函数的三种角色"></a><em>1. 函数的三种角色</em></h2><p>JS中函数有三种角色：普通函数、构造函数、对象;</p>
<ol>
<li>普通函数（函数名、形参、实参、返回值）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">a, b</span>) </span>{</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">} <span class="comment">// 函数定义</span></span><br><span class="line"><span class="keyword">var</span> result = sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 函数执行</span></span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>普通函数的执行过程（五步）</p>
</blockquote>
</li>
<li>构造函数、类（new 构造函数）：必须通过new 调用时，函数才能成为构造函数；<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Player</span>(<span class="params">name, age, site, devote = <span class="string">'lol'</span></span>) </span>{</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.site = site;</span><br><span class="line">  <span class="keyword">this</span>.devote = devote;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> t1 = <span class="keyword">new</span> Player(<span class="string">'faker'</span>, <span class="number">18</span>, <span class="string">'mid'</span>); <span class="comment">// 此时Player被new调用，Player才是真正成为一个构造函数</span></span><br><span class="line"><span class="keyword">let</span> t2 = Player(<span class="string">'khan'</span>, <span class="number">19</span>, <span class="string">'top'</span>); <span class="comment">// 普通调用时，Player还是普通函数</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>new调用构造函数的执行过程（七步）</p>
</blockquote>
</li>
<li>对象，和普通函数一样，键值对的集合（操作起来和普通对象一样）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> a - b</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.dir(fn)</span><br><span class="line"><span class="comment">// length: 函数形参个数</span></span><br><span class="line"><span class="comment">// name: '函数的名字'</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.name) <span class="comment">// 'fn'</span></span><br><span class="line"><span class="built_in">console</span>.log(fn.length) <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">fn.by = <span class="string">'edsyang'</span></span><br><span class="line">fn.timeWill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'time will tell'</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.dir(fn)</span><br><span class="line">fn.timeWill()</span><br><span class="line"><span class="comment">// 把函数当成一个普通对象时,通过 函数名.属性名 = 属性值 的方式添加的属性都是函数对象的私有属性；当你需要访问这些属性时，只能通过 函数名.属性名 的方式；</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fn</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="keyword">this</span>.name = <span class="string">'boy'</span></span><br><span class="line">}</span><br><span class="line">Fn.timeOut = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'we will have no time without time'</span>)</span><br><span class="line">} <span class="comment">// 把Fn当成一个对象添加一个私有属性</span></span><br><span class="line"><span class="comment">// 只有通过Fn.prototype.xxx = xxx 这样的形式才是给Fn的原型添加</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Fn()</span><br><span class="line">f1.timeOut()</span><br><span class="line"><span class="comment">// 实例能够使用的属性要么是私有属性（在构造函数中this.xxx = xxx得来的），要么就是实例所属类的原型（链）上的属性；</span></span><br></pre></td></tr></tbody></table></figure>
 把函数当成一个普通对象，给其添加的属性和方法称为 静态属性或方法；</li>
</ol>
<p><strong>Array.isArray()：静态方法，只能通过Array自己调用；检测一个值是否是一个数组，如果是返回true，不是就返回false</strong></p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内置类Array的一个静态方法：(ES6新增)</span></span><br><span class="line"><span class="built_in">Array</span>.isArray()</span><br><span class="line"><span class="comment">// 把Array当做普通对象使用，isArray是一个静态方法；判断一个值是否是一个数组，如果是数组返回true，不是数组返回false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(<span class="number">1</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray([<span class="number">1</span>, <span class="number">2</span>])); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-call＆apply＆bind"><a href="#2-call＆apply＆bind" class="headerlink" title="2. call＆apply＆bind"></a><em>2. call＆apply＆bind</em></h2><h3 id="2-1-call＆apply＆bind"><a href="#2-1-call＆apply＆bind" class="headerlink" title="2.1 call＆apply＆bind"></a><em>2.1 call＆apply＆bind</em></h3><p><strong>三种方法都在Function.prototype内</strong></p>
<p>都可以改变this的指向，但第一个参数如果是null、undefined或者不传参数的话，this仍然指向window；严格模式<code>use strict</code>下，第一个参数是null、undefined，this就指向null、undefined</p>
<blockquote>
<p>this的指向问题（8种）：事件函数、自执行函数、定时器的回调函数、全局作用域、函数执行、箭头函数、构造函数、call＆apply＆bind</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>{</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b);</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> obj = {</span><br><span class="line">  id: <span class="string">'864880624'</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li><p>call( )</p>
<blockquote>
<p>作用：修改函数中this的指向，并且把修改this后的函数执行</p>
</blockquote>
<p> 语法：函数名.call(ctx, 实参1, 实参2…)<br> 参数：ctx 就是用来替换函数中this的对象（修改this指向，新的this指向ctx），从第二个参数起，都是传递给函数的实参</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum.call(obj, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// call之后，this指向obj； 2 3 是传递给sum的实参</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>用call指向undefined、null或者不传参数，修改this无效，this仍然指向window</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">sum.call(<span class="literal">undefined</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">sum.call()</span><br></pre></td></tr></tbody></table></figure></li>
<li><p>apply( )</p>
<blockquote>
<p>作用：修改函数中this的指向，并且把修改this后的函数执行</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>但传参方式不同：call是一个一个地传递实参给sum，而apply是把实参都放到一个数组中，数组项是传递给sum的实参</p>
</blockquote>
<pre><code>语法：函数名.apply(ctx, [实参1，实参2...])
参数：ctx 就是用来替换函数中this的对象（修改this指向，新的this指向ctx），第二个参数是以数组的方式打包传递给函数的实参</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum.apply(obj, [<span class="number">11</span>, <span class="number">12</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">sum.apply(obj, ary);</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>用apply指向undefined、null或者不传参数，修改this无效，this仍然指向window</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sum.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">sum.apply(<span class="literal">undefined</span>, [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">sum.apply()</span><br></pre></td></tr></tbody></table></figure>
<ol start="3">
<li><p>bind( )</p>
<blockquote>
<p>作用：修改函数中的this，返回一个修改this后的新函数；不会让函数执行。</p>
</blockquote>
<p> 语法：函数名.bind(ctx, 实参1, 实参2…)<br> 参数：ctx 就是用来替换函数中this的对象（修改this指向，新的this指向ctx），从第二个参数起，都是传递给函数的实参</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum2 = sum.bind(obj, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 传参的时候和call一样，需要一个一个的传</span></span><br><span class="line"><span class="built_in">console</span>.log(sum2);</span><br><span class="line"><span class="built_in">console</span>.log(sum === sum2); <span class="comment">// false 因为sum2是一个新函数</span></span><br><span class="line">sum2(); <span class="comment">// 修改this后，需要自己执行一次这个函数</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数柯里化 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">a</span>)</span>{</span><br><span class="line">	<span class="comment">// a 保存在这个作用域中</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">b</span>)</span>{</span><br><span class="line">		<span class="comment">// b 被保存在这个作用域中</span></span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">c</span>)</span>{</span><br><span class="line">			<span class="comment">// c 保存在这个作用域中</span></span><br><span class="line">			<span class="keyword">return</span> a + b + c</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> r = curry(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br><span class="line"><span class="comment">/* bind方法实现函数柯里化 */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b,c</span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">	<span class="built_in">console</span>.log(a,b,c)</span><br><span class="line">	<span class="keyword">return</span> a + b + c</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> f = {</span><br><span class="line">	that:<span class="string">'123'</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> fn1 = fn.bind(<span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> fn2 = fn1.bind(<span class="literal">null</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> fn3 = fn2.bind(<span class="literal">null</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="2-2-求数组极值"><a href="#2-2-求数组极值" class="headerlink" title="2.2 求数组极值"></a><em>2.2 求数组极值</em></h3><blockquote>
<p>需求：求一个数组的最大值或最小值</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ary = [<span class="number">26</span>，<span class="number">58</span>，<span class="number">0</span>，<span class="number">-1</span>，<span class="number">666</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>先排序，再取极值（sort方法、假设法、排序算法、Math方法、数组转字符串再用eval执行）</p>
<blockquote>
<p>服务端给的数据大多数情况下都是服务端在查数据库的时候已经排好序了，使用的是SQL的关键字；SQL语句中，asc是指定列按升序排列，desc则是指定列按降序排列</p>
</blockquote>
<h4 id="2-2-1-sort方法"><a href="#2-2-1-sort方法" class="headerlink" title="2.2.1 sort方法"></a><em>2.2.1 sort方法</em></h4><pre><code>求最大值</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> b - a  <span class="comment">// 从大到小，降序</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">/* 从数组中取值只能通过 [索引] 把数组项取出 */</span></span><br><span class="line"><span class="keyword">let</span> max = ary[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>
<pre><code>求最小值</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ary.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> a - b  <span class="comment">// 从小到大，升序</span></span><br><span class="line">})</span><br><span class="line"><span class="comment">/* 从数组中取值只能通过 [索引] 把数组项取出 */</span></span><br><span class="line"><span class="keyword">let</span> min = ary[<span class="number">0</span>]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-2-假设法"><a href="#2-2-2-假设法" class="headerlink" title="2.2.2 假设法"></a><em>2.2.2 假设法</em></h4><pre><code>求最大值：假设数组的第一项是最大值，然后从第二项开始和假设的最大值比较，如果后面的值比假设值大，就把假设值改成较大的值</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = ary[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span> ; i &lt; ary.length ; i++){</span><br><span class="line">	<span class="keyword">if</span>(ary[i] &gt; max[<span class="number">0</span>]){</span><br><span class="line">		max = ary[i]</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(max)</span><br></pre></td></tr></tbody></table></figure>
<pre><code>求最小值：假设数组的第一项是最小值，然后从第二项开始和假设的最大值比较，如果后面的值比假设值小，就把假设值改成较小的值</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> min = ary[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">1</span> ; j &lt; ary.length ; j++){</span><br><span class="line">	<span class="keyword">if</span>(ary[j] &lt; min[<span class="number">0</span>]){</span><br><span class="line">		min = ary[j]</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(min)</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>面试题：求一串字符串中出现最多的字符及出现次数</p>
</blockquote>
<pre><code>思路：1、计数：对象法 ； 2、找到次数最多的是谁，即次数（假设法）</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'iYouthisnotatimeoflife'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = {}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; str.length ; i++){</span><br><span class="line">	<span class="keyword">let</span> item = str[i]</span><br><span class="line">	<span class="keyword">if</span>(obj[item] === <span class="literal">undefined</span>){</span><br><span class="line">		obj[item] = <span class="number">1</span> <span class="comment">// 此时item代表的字符在字符串中第一次出现</span></span><br><span class="line">	}<span class="keyword">else</span>{</span><br><span class="line">		<span class="comment">// obj[item] 不是undefined说明之前已经出现过了，所以此时只需要在原有的次数上累加即可</span></span><br><span class="line">		obj[item]++</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 经过循环之后，obj中有每个字母及字母出现的次数</span></span><br><span class="line"><span class="comment">// 找到出现次数最多的字符，以及出现次数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span> <span class="comment">// 假设出现次数最多的字符的次数</span></span><br><span class="line"><span class="keyword">let</span> chars = <span class="string">''</span> <span class="comment">// 假设出现次数最多的字符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> obj){</span><br><span class="line">	<span class="comment">// key 就是对象的属性 obj[key]</span></span><br><span class="line">	<span class="keyword">if</span>(obj[key] &gt; count){ <span class="comment">// 如果当前字母出现次数比count大，就要把假设值修改成这个较大值</span></span><br><span class="line">		count = obj[key]</span><br><span class="line">		chars = key </span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(count, chars)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-3-排序算法"><a href="#2-2-3-排序算法" class="headerlink" title="2.2.3 排序算法"></a><em>2.2.3 排序算法</em></h4><h4 id="2-2-4-Math方法（Math-max-和Math-min-）"><a href="#2-2-4-Math方法（Math-max-和Math-min-）" class="headerlink" title="2.2.4 Math方法（Math.max()和Math.min()）"></a><em>2.2.4 Math方法（Math.max()和Math.min()）</em></h4><pre><code>Math.max()和Math.min()只能接收一个一个的参数，怎么能让这个方法接收的数组作为参数或者把数组变成一项一项的 —— ...数组 -&gt; 展开运算符（ES6新增运算符）：把数组变成一项一项的</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...ary)</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min(...ary)</span><br></pre></td></tr></tbody></table></figure>
<pre><code>让Math.max()和Math.min()接收一个数组：使用apply方法，可以打包传递参数</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, ary)</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, ary)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-2-5-把数组toString-，然后再eval求值"><a href="#2-2-5-把数组toString-，然后再eval求值" class="headerlink" title="2.2.5 把数组toString()，然后再eval求值"></a><em>2.2.5 把数组toString()，然后再eval求值</em></h4><p><code>eval()</code> 方法：把字符串识别成JS代码并执行；比较消耗性能，尽量少用</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aryStr = ary.toString()</span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">eval</span>(<span class="string">`Math.max(<span class="subst">${aryStr}</span>)`</span>)</span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">eval</span>(<span class="string">`Math.min(<span class="subst">${aryStr}</span>)`</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-3-数组方法的实现"><a href="#2-3-数组方法的实现" class="headerlink" title="2.3 数组方法的实现"></a><em>2.3 数组方法的实现</em></h3><blockquote>
<p>push() ; pop() ; shift() ; unshift() ; slice(n, m) ; splice(n, m, x) ;concat() ; join() ; toString() ; indexOf() ; lastIndexOf() ; includes() ; sort(function(a,b){}) ; reverse() ; forEach(function(item, index){}) ; map(function(item, index){}) </p>
</blockquote>
<blockquote>
<p>forEach、map数组有多少项，回调函数就会执行多少回，并且爱执行的过程中会把当前数组项和当前索引传给回调函数</p>
</blockquote>
<h4 id="2-3-1-模拟数组方法"><a href="#2-3-1-模拟数组方法" class="headerlink" title="2.3.1 模拟数组方法"></a><em>2.3.1 模拟数组方法</em></h4><p><strong><em>push() 方法</em></strong></p>
<pre><code>1.向数组末尾追加一项到多项（实参个数不固定，用arguments）
2.返回数组的新长度</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.userDefined_Push = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="comment">// 当 数组.userDefined_Push() 的方式调用时，this就代表这个数组</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="built_in">arguments</span>.length ; i++){</span><br><span class="line">		<span class="keyword">this</span>[<span class="keyword">this</span>.length] = <span class="built_in">arguments</span>[i]</span><br><span class="line">		<span class="comment">/* 还可以用splice */</span></span><br><span class="line">		<span class="comment">// this.splice(this.length, 0, arguments[i])</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.length</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">let</span> result = ary.userDefined_Push(<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ary) <span class="comment">// [1, 3, 5, 7]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 4</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>pop() 方法</em></strong></p>
<pre><code>1.删除最后一项
2.返回被删除的项</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.userDefined_Pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">	<span class="comment">// 当 数组.userDefined_Pop() 的方式调用时，this就代表这个数组</span></span><br><span class="line">	<span class="keyword">let</span> last = <span class="keyword">this</span>[<span class="keyword">this</span>.length<span class="number">-1</span>] <span class="comment">// 因为pop()返回的是被删除的项，所以需要在删除之前提前存起来</span></span><br><span class="line">	<span class="keyword">this</span>.length-- <span class="comment">// 执行删除最后一项</span></span><br><span class="line">	<span class="keyword">return</span> last <span class="comment">// 把被删除的项返回</span></span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> result = ary.userDefined_Pop()</span><br><span class="line"><span class="built_in">console</span>.log(ary) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 5</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>slice() 方法</em></strong></p>
<pre><code>1.slice(n, m) 从索引n开始，到索引m（不含m）
2.slice(n) 从索引n开始，复制数组结尾
3.slice() n、m都不传，把这个数组从头到尾复制一遍</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.userDefined_Slice = <span class="function"><span class="keyword">function</span>(<span class="params">n, m</span>)</span>{</span><br><span class="line">    <span class="keyword">var</span> newAry = []</span><br><span class="line">    <span class="comment">// 不传参数的情况;只传一个参数/传多个参数并且传的第一个参数是非数字 —— 打印整个数组</span></span><br><span class="line">    <span class="keyword">if</span>((n === <span class="literal">undefined</span> &amp;&amp; m === <span class="literal">undefined</span>) || <span class="built_in">isNaN</span>(<span class="built_in">Number</span>(n))){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; ary.length ; i++){</span><br><span class="line">            newAry.push(ary[i])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> newAry</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 只传一个参数且是数字 —— 打印数组中从n最后 [n,)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp; <span class="built_in">arguments</span>.length === <span class="number">1</span>){</span><br><span class="line">        <span class="keyword">if</span>(n &gt;= <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j = n ; j &lt; ary.length ; j++){</span><br><span class="line">                newAry.push(ary[j])</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> newAry</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(n &lt; <span class="number">0</span>){</span><br><span class="line">            n = n + ary.length</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> k = n ; k &lt; ary.length ; k++){</span><br><span class="line">                newAry.push(ary[k])</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> newAry</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 传了两个参数并且都是数字类型的数字 —— 打印数组从n到m [n,m)</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp; <span class="keyword">typeof</span> m === <span class="string">'number'</span>){</span><br><span class="line">        (<span class="built_in">Number</span>(n) &lt; <span class="number">0</span>) ? n = n + ary.length : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        (<span class="built_in">Number</span>(m) &lt; <span class="number">0</span>) ? m = m + ary.length : <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> l = n ; l &lt; m ; l++){</span><br><span class="line">            newAry.push(ary[l])</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> newAry</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> result = ary.userDefined_Slice(<span class="number">-5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(ary) </span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="built_in">console</span>.log(ary.slice(<span class="number">-5</span>))</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>forEach(function(item, index){}) 方法</em></strong></p>
<pre><code>1.参数是一个回调函数
2.数组有多少项，回调函数就需要执行多少次，在执行的过程中，还需要把数组的当前项和当前项的索引传递给回调函数
3.forEach不需要返回值</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.userDefined_ForEach = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{</span><br><span class="line">	<span class="comment">// callback就代表回调函数，回调函数执行就是 callback()</span></span><br><span class="line">	<span class="comment">// 数组有多少项回调函数就需要执行多少次，所以需要一个for loop</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">this</span>.length ; i++){</span><br><span class="line">		<span class="comment">// this[i] 代表当前项  ； i 代表当前项的索引</span></span><br><span class="line">		callback(<span class="keyword">this</span>[i], i)</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">ary.userDefined_ForEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(item, index)</span><br><span class="line">})</span><br><span class="line">ary.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>{</span><br><span class="line">	<span class="built_in">console</span>.log(item, index)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p><strong><em>map(function(item, index){}) 方法</em></strong></p>
<pre><code>1.参数是一个回调函数
2.数组有多少项，回调函数就需要执行多少次，在执行的过程中，还需要把数组的当前项和当前项的索引传递给回调函数
3.map需要返回一个新数组</code></pre><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.userDefined_Map = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>{</span><br><span class="line">	<span class="keyword">let</span> newAry = []</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="keyword">this</span>.length ; i++){</span><br><span class="line">		<span class="keyword">let</span> result = callback(<span class="keyword">this</span>[i], i)</span><br><span class="line">		newAry.push(result)</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> newAry</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> ary = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> ary1 = ary.userDefined_Map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> item </span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(ary1)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="2-4-类数组转数组"><a href="#2-4-类数组转数组" class="headerlink" title="2.4 类数组转数组"></a><em>2.4 类数组转数组</em></h3><pre><code>类数组：有索引、length的对象
常见的类数组：arguments、DOM元素对象集合</code></pre><blockquote>
<p>数组有很多方法，但只能给数组的实例用，如果能将类数组转成数组，数组的方法就可以使用了</p>
</blockquote>
<h4 id="2-4-1-类数组转数组的方法"><a href="#2-4-1-类数组转数组的方法" class="headerlink" title="2.4.1 类数组转数组的方法"></a><em>2.4.1 类数组转数组的方法</em></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'div'</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>1.准备一个新数组，遍历这个类数组对象，把类数组中的每一项push到新数组中<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newAry1 = []</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; divList.length ; i++){</span><br><span class="line">	newAry.push(divList[i])</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(newAry1)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(newAry1)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>2.把类数组对象通过展开运算符展开到一个数组中（ES6新增，不兼容低版本浏览器）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newAry2 = [...divList]</span><br><span class="line"><span class="built_in">console</span>.log(newAry2)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(newAry2)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>3.借用数组原型上的slice方法<blockquote>
<p>借用Array.prototype.slice()方法，在slice执行时，把slice中的this修改成类数组，就可以实现把类数组转成数组</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newAry3 = <span class="built_in">Array</span>.prototype.slice.call(divList)</span><br><span class="line"><span class="comment">// 简写方法：[].slice.call(divList)</span></span><br><span class="line"><span class="built_in">console</span>.log(newAry3)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(newAry3)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>4.Array.from() 把类数组对象(类数组结构、iterator对象)转变成数组；ES6新增<br><code>静态方法：类.属性</code><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newAry4 = <span class="built_in">Array</span>.from(divList)</span><br><span class="line"><span class="built_in">console</span>.log(newAry4)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(newAry4)) <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<h4 id="2-4-2-类数组转数组方法封装"><a href="#2-4-2-类数组转数组方法封装" class="headerlink" title="2.4.2 类数组转数组方法封装"></a><em>2.4.2 类数组转数组方法封装</em></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 函数文件注释快捷键：ctrl+alt+t */</span></span><br><span class="line"><span class="comment">/* 写注释是个好习惯，但是要注意如果功能变更要维护这些注释 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: （方法功能描述）类数组转数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>arrLike（方法的参数） 参数的意义： 类数组转对象  类型：对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: {any[]} 返回值意义：返回值是什么，类型是什么</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrLikeToAry</span>(<span class="params">arrLike</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Array</span>.from(arrLike)	</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Array.from是ES6的新特性，只能在高版本的浏览器使用。如果在老旧浏览器中使用，就会报错；所以这个时候需要做容错（异常）处理</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-4-3-try-catch容错处理（异常捕获）"><a href="#2-4-3-try-catch容错处理（异常捕获）" class="headerlink" title="2.4.3 try-catch容错处理（异常捕获）"></a><em>2.4.3 try-catch容错处理（异常捕获）</em></h4><p>try-catch 语句用于JS的异常处理；因为JS是单线程的，一旦程序出现异常，后面的代码就不会执行了。所以使用try-catch语句异常捕获。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>{</span><br><span class="line">	<span class="comment">// 可能会引发异常的代码</span></span><br><span class="line">}<span class="keyword">catch</span> (e){</span><br><span class="line">	<span class="comment">// 上面try中的代码报错后会执行这个代码块中的代码；如果try中的代码不报错，这里的代码不会执行</span></span><br><span class="line">	<span class="comment">// e 是错误信息，这个错误信息内包含了上面try的时候引发的异常；拿到这个错误后可以选择在浏览器中抛出异常；（有一些做报错或性能监控的时候，需要回传给服务器）</span></span><br><span class="line">	<span class="comment">// 如果在catch语句中报错，并且也没有其他的容错处理，就会报错，并且后面的代码也不会再执行了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>利用try-catch语句改造类数组转数组的方法，使用这个方法兼容所有的浏览器<br>try-catch语句增强代码的健壮性，但是开发效率就会相应降低</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrLikeToAry</span>(<span class="params">aryLike</span>)</span>{</span><br><span class="line">	<span class="comment">// 先尝试ES6语法</span></span><br><span class="line">	<span class="keyword">try</span>{</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Array</span>.from(aryLike)</span><br><span class="line">	}<span class="keyword">catch</span>(e){</span><br><span class="line">		<span class="comment">// 如果代码执行到catch语句，说明try中的Array.from报错；所以需要兼容处理</span></span><br><span class="line">		<span class="keyword">var</span> newAry = []</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; aryLike.length ; i++){</span><br><span class="line">			newAry.push(aryLike[i])</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">return</span> newAry</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> divList = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">var</span> toAry = arrLiketoAry(divList)</span><br><span class="line"><span class="built_in">console</span>.log(toAry)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="2-4-4-JS中常见的报错信息"><a href="#2-4-4-JS中常见的报错信息" class="headerlink" title="2.4.4 JS中常见的报错信息"></a><em>2.4.4 JS中常见的报错信息</em></h4><pre><code>SyntaxError（语法错误）
ReferenceError（引用错误）
RangeError（范围错误）
TypeError（类型错误）
URLError（URL错误）
EvalError（eval错误）</code></pre><h2 id="3-箭头函数"><a href="#3-箭头函数" class="headerlink" title="3. 箭头函数"></a><em>3. 箭头函数</em></h2><h3 id="3-1-标准函数和箭头函数语法区别"><a href="#3-1-标准函数和箭头函数语法区别" class="headerlink" title="3.1 标准函数和箭头函数语法区别"></a><em>3.1 标准函数和箭头函数语法区别</em></h3><p>标准函数语法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>)</span>{</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>箭头函数语法</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">a, b</span>) =&gt;</span> {</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">}</span><br><span class="line"><span class="keyword">var</span> r = sum(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="built_in">console</span>.log(r)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="3-2-简化语法"><a href="#3-2-简化语法" class="headerlink" title="3.2 简化语法"></a><em>3.2 简化语法</em></h3><p>1.当参数只有一个时，形参入口的小括号可以不写</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ok = <span class="function"><span class="params">fn</span> =&gt;</span> {</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'I am fine'</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2.当函数只有一行代码时，可以省略花括号和return关键字</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ok2 = <span class="function"><span class="params">fn</span> =&gt;</span> <span class="string">'I am fine'</span></span><br><span class="line"><span class="built_in">console</span>.log(ok2())</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>当返回一个对象的时候，要用小括号包裹</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ok3 = <span class="function"><span class="params">fn</span> =&gt;</span> ({<span class="attr">name</span>:<span class="string">'fine'</span>})</span><br><span class="line"><span class="built_in">console</span>.log(ok3())</span><br></pre></td></tr></tbody></table></figure>
<p>3.箭头函数中没有arguments，但是可以使用不定参数（剩余参数）</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function">(<span class="params">...arg</span>) =&gt;</span> {</span><br><span class="line">	<span class="built_in">console</span>.log(arg)</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arg)) <span class="comment">// true 剩余参数是一个真正的数组</span></span><br><span class="line">}</span><br><span class="line">sum(<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>不定参数（… 展开运算符；剩余运算符）：</p>
<blockquote>
<p>在剩余运算符后面不能再添加形参</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum2 = <span class="function">(<span class="params">a, b, ...arg</span>) =&gt;</span> {</span><br><span class="line">	<span class="comment">// 此时arg表示除了a，b剩下的实参；从第三个及以后的实参会放到arg中</span></span><br><span class="line">	<span class="built_in">console</span>.log(arg)</span><br><span class="line">}</span><br><span class="line">sum2(<span class="number">1</span>) <span class="comment">// arg = [] arg是一个数组，里面没有值时是个空数组</span></span><br><span class="line">sum2(<span class="number">1</span>,<span class="number">2</span>) <span class="comment">// arg = []</span></span><br><span class="line">sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// arg = [3]</span></span><br><span class="line">sum2(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>) <span class="comment">// arg = [3,4]</span></span><br></pre></td></tr></tbody></table></figure>
<p>4.箭头函数中没有自己的this，所以箭头函数里面的this是箭头函数声明时所在作用域中的this（上级作用域中的this）</p>
<p><strong>arguments和this是函数执行时，解析引擎传给函数的，箭头函数执行时，JS解析引擎没有给传</strong></p>
<pre><code>箭头函数不能用来做构造函数（因为自身没有this）
箭头函数也没有自己的prototype
箭头函数同样是Function的实例</code></pre><h2 id="4-sort应用"><a href="#4-sort应用" class="headerlink" title="4. sort应用"></a><em>4. sort应用</em></h2><blockquote>
<p>sort原理：相邻项比较，a就是前一项，b是后一项；利用回调函数的返回值（a - b或者b - a的结果）和零的关系有如下操作：<br>    如果回调函数返回值大于0，交换两项的位置；<br>    如果回调函数返回值小于等于0，不交换位置；<br>    如果回调函数什么都不返回，原数组不发生变化</p>
</blockquote>
<ul>
<li>sort() 不传参数也可以排序，但只能排0-9之间的数字（只能排相同位数的）；字符串进行sort排序，没有参数时，按unicode码排序<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">14</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">15</span>, <span class="number">13</span>, <span class="number">16</span>];</span><br><span class="line"><span class="keyword">var</span> r1 = ary.sort(); <span class="comment">// &nbsp;[0, 1, 13, 14, 15, 16, 2, 5, 8]</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>sort(callback) 可以传所有的<ul>
<li>普通数字升/降序 sort(function(a, b){return a - b / b - a})</li>
<li>排数组对象（二维数组）不是只排属性，把这些对象重新排序</li>
<li>排页面中的HTML元素集合，找到这个元素对象和排序维度之间的关系，如 元素对象.innerHTML / 元素对象.getAttribute()<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 回调函数 */</span></span><br><span class="line"><span class="keyword">var</span> ary1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">ary4.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> {</span><br><span class="line">  <span class="comment">// console.log(a, b);</span></span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">});</span><br><span class="line">------------------------------</span><br><span class="line"><span class="comment">/* 数组对象（二维数组） */</span></span><br><span class="line"><span class="keyword">var</span> ary2 = [ <span class="comment">// 数组项可以是任意数据类型的</span></span><br><span class="line">  {</span><br><span class="line">    name: <span class="string">'张三'</span>,</span><br><span class="line">    age: <span class="number">15</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    name: <span class="string">'李四'</span>,</span><br><span class="line">    age: <span class="number">18</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    name: <span class="string">'王五'</span>,</span><br><span class="line">    age: <span class="number">14</span></span><br><span class="line">  },</span><br><span class="line">  {</span><br><span class="line">    name: <span class="string">'杨六'</span>,</span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">  }</span><br><span class="line">]; </span><br><span class="line"><span class="comment">// 如果数组项是是对象，我们按照对象的某个属性排序时，在回调函数中return a.属性名 - b.属性名；就可以实现数组中的项按照这个属性升序排序；（不是只把这个属性值排序，而是数组项整体排序）</span></span><br><span class="line">ary2.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>{</span><br><span class="line">  <span class="comment">// console.log(a - b);</span></span><br><span class="line">  <span class="keyword">return</span> a.age - b.age</span><br><span class="line">});</span><br><span class="line"><span class="comment">// console.log(ary6);</span></span><br></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script><!-- flag of hidden posts --></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1966861494@qq.com">Edsyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lagerstroemia.com.cn/2019/07/20/course/origin/06-Chapter%20Four-A.part%20one/">http://blog.lagerstroemia.com.cn/2019/07/20/course/origin/06-Chapter%20Four-A.part%20one/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lagerstroemia.com.cn" target="_blank">Edsyang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS-Notes/">JS Notes</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WgFk4Onl7sisfXpq9vHcehGJ-gzGzoHsz',
  appKey: '3DLR7iLY5al5dbIdo9kWnDHU',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Edsyang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19038398号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>