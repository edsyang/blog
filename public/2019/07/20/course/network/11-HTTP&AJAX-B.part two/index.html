<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>网络 - Chapter One.B | Edsyang</title><meta name="description" content="8. ⚠️Promise⚠️ES6&#x2F;浏览器新增的内置类，用来管理异步的；Promise是同步的，new Promise（创建Promise的实例）时传递的回调函数同步执行的，then里面的回调函数是异步执行的。 1234567891011let p &#x3D; new Promise(function (resolve, reject) {    &#x2F;&#x2F; 这个函数是同步执行    &#x2F;&#x2F; 函数里面放的是异步处"><meta name="keywords" content="JS Notes"><meta name="author" content="Edsyang,1966861494@qq.com"><meta name="copyright" content="Edsyang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.svg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="网络 - Chapter One.B"><meta name="twitter:description" content="8. ⚠️Promise⚠️ES6&#x2F;浏览器新增的内置类，用来管理异步的；Promise是同步的，new Promise（创建Promise的实例）时传递的回调函数同步执行的，then里面的回调函数是异步执行的。 1234567891011let p &#x3D; new Promise(function (resolve, reject) {    &#x2F;&#x2F; 这个函数是同步执行    &#x2F;&#x2F; 函数里面放的是异步处"><meta name="twitter:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="og:type" content="article"><meta property="og:title" content="网络 - Chapter One.B"><meta property="og:url" content="http://blog.lagerstroemia.com.cn/2019/07/20/course/network/11-HTTP&amp;AJAX-B.part%20two/"><meta property="og:site_name" content="Edsyang"><meta property="og:description" content="8. ⚠️Promise⚠️ES6&#x2F;浏览器新增的内置类，用来管理异步的；Promise是同步的，new Promise（创建Promise的实例）时传递的回调函数同步执行的，then里面的回调函数是异步执行的。 1234567891011let p &#x3D; new Promise(function (resolve, reject) {    &#x2F;&#x2F; 这个函数是同步执行    &#x2F;&#x2F; 函数里面放的是异步处"><meta property="og:image" content="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><meta property="article:published_time" content="2019-07-20T03:38:34.724Z"><meta property="article:modified_time" content="2020-05-10T02:26:18.150Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://blog.lagerstroemia.com.cn/2019/07/20/course/network/11-HTTP&amp;AJAX-B.part%20two/"><link rel="prev" title="Node - Chapter One.B" href="http://blog.lagerstroemia.com.cn/2019/07/20/course/node/12-Node.js-B.part%20two/"><link rel="next" title="Node - Chapter One.A" href="http://blog.lagerstroemia.com.cn/2019/07/20/course/node/12-Node.js-A.part%20one/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: {"languages":{"author":"作者: Edsyang","link":"链接: ","source":"来源: Edsyang","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Edsyang" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">152</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">37</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-⚠️Promise⚠️"><span class="toc-number">1.</span> <span class="toc-text">8. ⚠️Promise⚠️</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-Promise应用"><span class="toc-number">1.1.</span> <span class="toc-text">8.1 Promise应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-Promise-all"><span class="toc-number">1.2.</span> <span class="toc-text">8.2 Promise.all</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-宏任务和微任务"><span class="toc-number">2.</span> <span class="toc-text">9. 宏任务和微任务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-async和await"><span class="toc-number">3.</span> <span class="toc-text">10. async和await</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-async和await改写：login-js"><span class="toc-number">3.1.</span> <span class="toc-text">10.1 async和await改写：login.js</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-！练习"><span class="toc-number">3.2.</span> <span class="toc-text">10.2 ！练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-cookie"><span class="toc-number">4.</span> <span class="toc-text">11. cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-浏览器操作cookie"><span class="toc-number">4.1.</span> <span class="toc-text">11.1 浏览器操作cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-session"><span class="toc-number">5.</span> <span class="toc-text">12. session</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-session和cookie的区别与联系"><span class="toc-number">5.1.</span> <span class="toc-text">12.1 session和cookie的区别与联系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-token"><span class="toc-number">6.</span> <span class="toc-text">13. token</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-GIT"><span class="toc-number">7.</span> <span class="toc-text">14. GIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-GIT的使用"><span class="toc-number">7.1.</span> <span class="toc-text">14.1 GIT的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-GIT分支-需要自己百度增加，有的不对"><span class="toc-number">7.2.</span> <span class="toc-text">14.2 GIT分支  &#x2F;&#x2F;&#x2F; 需要自己百度增加，有的不对 &#x2F;&#x2F;&#x2F;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-分支开发流程"><span class="toc-number">7.3.</span> <span class="toc-text">14.3 分支开发流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-分支提测流程"><span class="toc-number">7.4.</span> <span class="toc-text">14.4 分支提测流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-上线（发版）"><span class="toc-number">7.5.</span> <span class="toc-text">14.5 上线（发版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-多人协作"><span class="toc-number">7.6.</span> <span class="toc-text">14.6 多人协作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-SSH-KEY"><span class="toc-number">7.7.</span> <span class="toc-text">14.7 SSH-KEY</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Edsyang</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">网络 - Chapter One.B</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2019-07-20 03:38:34"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-07-20</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-10 02:26:18"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-10</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="8-⚠️Promise⚠️"><a href="#8-⚠️Promise⚠️" class="headerlink" title="8. ⚠️Promise⚠️"></a><em>8. ⚠️Promise⚠️</em></h2><p>ES6/浏览器新增的内置类，用来管理异步的；Promise是同步的，new Promise（创建Promise的实例）时传递的回调函数同步执行的，then里面的回调函数是异步执行的。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    <span class="comment">// 这个函数是同步执行</span></span><br><span class="line">    <span class="comment">// 函数里面放的是异步处理的任务</span></span><br><span class="line">});</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="comment">// 异步处理成功后执行的操作写在then的第一个回调函数中</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">}), <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="comment">// 异步处理失败后执行的操作写在then的第二个回调函数中</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Promise实例有三种状态：<ul>
<li>pending：Promise实例初始化成功，正在处理异步</li>
<li>fulfilled：异步处理成功</li>
<li>rejected：异步处理失败<blockquote>
<p>Promise对象的状态只能从pending变成fulfilled或者rejected；一旦发生变更状态就会凝固，不能再发生变化</p>
</blockquote>
</li>
</ul>
</li>
<li>Promise实例中的回调函数是同步执行的，里面放的都是异步处理的任务<ul>
<li>resolve 是一个函数，在异步处理成功后执行，有两个作用：<ul>
<li>1.修改Promise实例的状态从pending变为fulfilled；</li>
<li>2.执行一个事件池，这个事件池中收集了所有then方法的第一个回调函数</li>
</ul>
</li>
<li>reject 是一个函数，在异步处理失败后执行，有两个作用：<ul>
<li>1.修改Promise实例的状态从pending变为rejected；</li>
<li>2.执行一个事件池，这个事件池中收集了所有then方法的第二个回调函数<blockquote>
<p>resolve或reject在执行的时候收到的实参会传递给第一个then方法的回调函数</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>then方法中的回调函数执行规律<ul>
<li>第一个then方法比较特殊，它的两个回调函数中哪个能执行，取决于创建Promise实例时到底是resolve还是reject；如果是resolve，第一个then的第一个回调函数执行；如果是reject，第一个then的第二个回调函数执行</li>
<li>后面的then方法中哪个回调函数能执行，取决于前面then方法中的执行情况（两种）<ul>
<li>1.前一个then方法的回调函数没有返回Promise实例时，无论前面的then是哪个回调函数执行，都会执行第一个回调函数；前面then的回调函数的返回值会传给下一个then回调函数；如果前面then回调函数执行时报错了，就会执行第二个，并且报错信息会传递给第二个回调函数</li>
<li>2.当前面的then方法的回调函数返回了Promise实例时；后面then方法的哪个回调函数能执行，取决于前面then方法返回的Promise实例的状态；如果前面返回的实例resolve，后面then的第一个回调函数就会执行；如果前面返回的实例reject，后面then的第二个回调函数就会执行；并且前面then的回调函数返回的实例resolve或reject执行时收到的实参，会传给下一个then要执行的回调函数<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>{</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">        resolve(<span class="string">'abc'</span>)</span><br><span class="line">        <span class="comment">// reject('xyz')</span></span><br><span class="line">    }, <span class="number">1000</span>)</span><br><span class="line">});</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">result</span>) </span>{</span><br><span class="line">    <span class="comment">// throw '就要报错'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">    <span class="comment">// return 'ok'</span></span><br><span class="line">    <span class="comment">/* return new Promise(function (resolve, reject) {</span></span><br><span class="line"><span class="comment">        resolve('前面实例resolve')</span></span><br><span class="line"><span class="comment">        reject('前面实例reject')</span></span><br><span class="line"><span class="comment">    }) */</span></span><br><span class="line">}, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="comment">// return 'not ok'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有一个then的情况：</span></span><br><span class="line"><span class="comment">// 仅resolve('abc')执行： 1 'abc'</span></span><br><span class="line"><span class="comment">// 仅reject('xyx')执行：2 'xyz'</span></span><br><span class="line"><span class="comment">// resolve('abc') reject('xyz')执行：1 'abc' 因为Promise的状态一旦发生变化就凝固了，不能再变化</span></span><br><span class="line"><span class="comment">// reject('xyz') resolve('abc')执行：2 'xyz'</span></span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params">result2</span>) </span>{</span><br><span class="line">    <span class="comment">// result2是上面then回调函数的返回值，如果没有return或者return一个空获得的是undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(result2)</span><br><span class="line">}, <span class="function"><span class="keyword">function</span> (<span class="params">error2</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(error2);</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 有两个then的情况：</span></span><br><span class="line"><span class="comment">// 仅resolve('abc')执行： 1 'abc' 3 undefined</span></span><br><span class="line"><span class="comment">// 仅reject('xyx')执行：2 'xyz' 3 undefined</span></span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-1-Promise应用"><a href="#8-1-Promise应用" class="headerlink" title="8.1 Promise应用"></a><em>8.1 Promise应用</em></h3><p>请求两个接口：先请求login.json；如果登录成功的话再请求banner.json，并且把响应结果输出到控制台；如果登录失败的话，alert提示错误</p>
<blockquote>
<p>不用Promise -&gt; 像这种不断嵌套的写法叫做回调地狱（callback hell）</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$.ajax({</span><br><span class="line">    url: <span class="string">'login.json'</span>,</span><br><span class="line">    type: <span class="string">'GET'</span>,</span><br><span class="line">    cache: <span class="literal">false</span>,</span><br><span class="line">    dataType: <span class="string">'json'</span>,</span><br><span class="line">    error(err) {</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    },</span><br><span class="line">    success(data) {</span><br><span class="line">        <span class="keyword">if</span> (+data.code === <span class="number">0</span>) { <span class="comment">// + 强制转换，相当于Number()</span></span><br><span class="line">            $.ajax({</span><br><span class="line">                url: <span class="string">'banner.json'</span>,</span><br><span class="line">                type: <span class="string">'GET'</span>,</span><br><span class="line">                cache: <span class="literal">false</span>,</span><br><span class="line">                dataType: <span class="string">'json'</span>,</span><br><span class="line">                error(err2) {</span><br><span class="line">                    <span class="built_in">console</span>.log(err2)</span><br><span class="line">                },</span><br><span class="line">                success(data2) {</span><br><span class="line">                    <span class="built_in">console</span>.log(data2)</span><br><span class="line">                }</span><br><span class="line">            })</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            alert(<span class="string">'登录失败：'</span> + data.msg)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>使用Promise -&gt; 解决回调地狱（callback hell）</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    $.ajax({</span><br><span class="line">        url: <span class="string">'login.json'</span>,</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        cache: <span class="literal">false</span>, <span class="comment">// 没有缓存，原理是加一个时间戳或随机数</span></span><br><span class="line">        dataType: <span class="string">'json'</span>,</span><br><span class="line">        error(err) {</span><br><span class="line">            reject(err)</span><br><span class="line">        },</span><br><span class="line">        success(data) {</span><br><span class="line">            <span class="keyword">if</span>(+data.code === <span class="number">0</span>) {</span><br><span class="line">                resolve(data)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                reject(data)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">});</span><br><span class="line"><span class="comment">// 根据p的状态采取不同的操作</span></span><br><span class="line">p.then(<span class="function">(<span class="params">result</span>) =&gt;</span> {</span><br><span class="line">    <span class="comment">// 如果上一步成功才会执行这个回调函数</span></span><br><span class="line">    <span class="comment">// 直接return ajax，不用new Promise，不用后面的.then，只是按照格式来写而已，可以省略，没什么作用！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        $.ajax({</span><br><span class="line">            url: <span class="string">'banner.json'</span>,</span><br><span class="line">            type: <span class="string">'GET'</span>,</span><br><span class="line">            cache: <span class="literal">false</span>,</span><br><span class="line">            dataType: <span class="string">'json'</span>,</span><br><span class="line">            error(err){</span><br><span class="line">                reject(err);</span><br><span class="line">            },</span><br><span class="line">            success(data){</span><br><span class="line">                <span class="keyword">if</span>(+data.code === <span class="number">0</span>){</span><br><span class="line">                    resolve(data);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    reject(data);</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">        });</span><br><span class="line">    });</span><br><span class="line">}, (err) =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">}).then(<span class="function">(<span class="params">result2</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(result2)</span><br><span class="line">}, (err2) =&gt; {</span><br><span class="line">    <span class="built_in">console</span>.log(err2)</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-2-Promise-all"><a href="#8-2-Promise-all" class="headerlink" title="8.2 Promise.all"></a><em>8.2 Promise.all</em></h3><p>有两个接口：login.json和banner.json；这两个接口并没有什么联系，但是需要都请求完才能渲染数据；</p>
<p>同时请求多个接口，这些接口都请求完才能做某件事情，这个时候要用到一个方法：</p>
<ul>
<li>Promise.all( [ promise实例1, promise实例2… ] ) <ul>
<li>Promise的静态方法</li>
<li>接收一个数组，数组项都是Promise实例</li>
<li>返回一个新的Promise实例，如果数组中送有的Promise都resolve，新返回的Promise实例就是resolve；只要数组中有一个reject，新返回的Promise实例就是reject<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    $.ajax({</span><br><span class="line">        url: <span class="string">'login.json'</span>,</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        cache: <span class="literal">false</span>,</span><br><span class="line">        dataType: <span class="string">'json'</span>,</span><br><span class="line">        error(err) {</span><br><span class="line">            reject(err)</span><br><span class="line">        },</span><br><span class="line">        success(data) {</span><br><span class="line">            resolve(<span class="string">'ABC'</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    $.ajax({</span><br><span class="line">        url: <span class="string">'banner.json'</span>,</span><br><span class="line">        type: <span class="string">'GET'</span>,</span><br><span class="line">        cache: <span class="literal">false</span>,</span><br><span class="line">        dataType: <span class="string">'json'</span>,</span><br><span class="line">        error(err) {</span><br><span class="line">            reject(err)</span><br><span class="line">        },</span><br><span class="line">        success(data) {</span><br><span class="line">            resolve(<span class="string">'XYZ'</span>)</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">})</span><br><span class="line"><span class="comment">// result是一个数组。是all方法的数组中所有的promise实例在resolve的时候传入的实参，而且是按照顺序的</span></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2]).then(<span class="function">(<span class="params">result</span>) =&gt;</span> <span class="built_in">console</span>.log(result)).catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="9-宏任务和微任务"><a href="#9-宏任务和微任务" class="headerlink" title="9. 宏任务和微任务"></a><em>9. 宏任务和微任务</em></h2><p><strong>宏任务和微任务是等待任务队列中的异步任务的处理机制</strong></p>
<ul>
<li>浏览器的任务队列：<ul>
<li>主任务队列：存储的都是同步任务</li>
<li>等待任务队列：存储的都是异步任务<blockquote>
<p>首先浏览器会把主任务队列中的同步任务全部执行完后，再去等待任务队列中看哪个任务达到执行条件了，把达到执行条件的任务放到主任务队列中去执行，等这些任务执行完后再去等待任务队列中看哪个任务达到执行条件，再把达到执行条件的任务放到主任务队列中执行…如此循环，这种循环叫做<strong>事件循环（Event loop）</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>微任务<ul>
<li>Promise的then回调函数</li>
<li>async函数中await下面的代码</li>
<li>process.nextTick</li>
</ul>
</li>
<li>宏任务<ul>
<li>定时器（setInterval/setTimeout）<blockquote>
<p>异步任务执行的规则是看谁先达到执行条件，但是谁先到达执行条件也有优先级的问题，这个优先级要看这个任务是宏任务还是微任务；<strong>微任务的优先级比宏任务的优先级要高</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>当主任务队列中同步任务执行完，先去等待任务队列中把所有的微任务找到并且执行这些微任务，等微任务执行完再去把宏任务找出来并且执行</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(); <span class="comment">// resolve执行并不是让then里面的回调函数立即执行，resolve执行只是告诉then的回调函数到达执行条件了；而then里面的回调函数异步执行的，需要等着所有的同步任务执行结束才能执行它</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">});</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">});</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line"><span class="comment">// 5 2 3 6 7 【主任务队列中的同步任务都执行完了】 4 1 </span></span><br><span class="line"><span class="comment">// 为什么4先输出？因为定时器是宏任务，then里面的回调函数是微任务；因为微任务的优先级比宏任务优先级高</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-async和await"><a href="#10-async和await" class="headerlink" title="10. async和await"></a><em>10. async和await</em></h2><p><strong>async和await是ES6新增的关键字，用于把异步变同步</strong></p>
<blockquote>
<p>真实的项目中，async和await常结合AJAX和Promise一起使用</p>
</blockquote>
<p>async在函数定义时使用，用async定义的函数默认返回一个Promise实例，可以直接.then</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fx</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">} </span><br><span class="line"><span class="keyword">let</span> obj = {</span><br><span class="line">    <span class="keyword">async</span> getName() { <span class="comment">// async还可以定义对象的方法</span></span><br><span class="line"></span><br><span class="line">    } </span><br><span class="line">}</span><br><span class="line">fx().then(<span class="function"><span class="params">()</span> =&gt;</span> { <span class="comment">// 因为async函数返回了Promise实例，所以可以.then</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>await（要和async一起使用）用法：</p>
<ol>
<li>如果await右侧是同步的代码，就会让同步代码执行；如果执行的是一个函数，还会把这个函数的返回值给到await左边的变量（相当于await的返回值）</li>
<li>如果await右侧是一个Promise实例，或者一个方法返回了Promise实例，await会等着Promise的实例resolve，并且在实例resolve之前，await后面的代码不执行；还会拿到Promise在resolve时传入的值并且赋值给等号左侧变量（相当于await的返回值）</li>
<li>await会把await下面的代码变成微任务<blockquote>
<p>await有返回值，如果右边是一个值，就把这个值返回；如果是Promise，获取Promise resolve时传递的数据；</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>await 等待，等它右侧的代码执行完；后面经常跟一个Promise实例或者跟返回Promise实例的方法</p>
</blockquote>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">h</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">            resolve(<span class="string">'xyz'</span>)</span><br><span class="line">        }, <span class="number">1000</span>)</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">await</span> g()</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">    <span class="keyword">let</span> y = <span class="keyword">await</span> h()</span><br><span class="line">    <span class="built_in">console</span>.log(y)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'123'</span>)</span><br><span class="line">    <span class="comment">// 如果不用await h().then((res) =&gt; console.log(res)) 有了async和await就不用写then了；因为await可以取得promise resolve时传入的值</span></span><br><span class="line">}</span><br><span class="line">fn()</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-1-async和await改写：login-js"><a href="#10-1-async和await改写：login-js" class="headerlink" title="10.1 async和await改写：login.js"></a><em>10.1 async和await改写：login.js</em></h3><p>用async和await改写先请求login.json再请求banner.json，并且在请求结束后渲染到页面中</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLogin</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'login.json'</span>)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="regexp">/^2\d{2}&amp;/</span>) {</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        xhr.send()</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getBanner</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> {</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, <span class="string">'banner.json?token='</span> + token)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="regexp">/^2\d{2}&amp;/</span>) {</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        xhr.send()</span><br><span class="line">    })</span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bindHTML</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="keyword">let</span> login = <span class="keyword">await</span> getLogin()</span><br><span class="line">    <span class="comment">// 从登陆信息中取得token，把token传给getBanner（第二个接口依赖第一个接口中的内容，用await等前面的接口相应完，就可以拿到数据，然后把想要的数据从里面拿出来再传给下一个请求）</span></span><br><span class="line">    <span class="keyword">let</span> { <span class="attr">data</span>: { token } } = login</span><br><span class="line">    <span class="keyword">let</span> banner = <span class="keyword">await</span> getBanner(token)</span><br><span class="line">    <span class="comment">// 下面可以执行绑定数据的操作，这里可以写开启轮播图的事情</span></span><br><span class="line">}</span><br><span class="line">bindHTML().then(<span class="function"><span class="params">()</span> =&gt;</span> {</span><br><span class="line">    <span class="comment">// 还可以在这个回调函数写开启轮播图的事情</span></span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure>
<p>login.json</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"code"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"data"</span>: {</span><br><span class="line">        <span class="attr">"token"</span>: <span class="string">"dsaf1si3hfaskjlf3"</span></span><br><span class="line">    },</span><br><span class="line">    <span class="attr">"msg"</span>: <span class="string">"ok"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-2-！练习"><a href="#10-2-！练习" class="headerlink" title="10.2 ！练习"></a><em>10.2 ！练习</em></h3><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">await</span> async2(); </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>); </span><br><span class="line">}</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">}</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>) </span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">}, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">6</span>); </span><br><span class="line">    resolve();</span><br><span class="line">}).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>{</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">7</span>)</span><br><span class="line">})</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>); </span><br><span class="line"><span class="comment">// 4 1 3 6 8 2 7 undefined 5 老师答案</span></span><br><span class="line"><span class="comment">// 4 1 3 6 8 2 7 5 大众答案 https://segmentfault.com/a/1190000015057278</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="11-cookie"><a href="#11-cookie" class="headerlink" title="11. cookie"></a><em>11. cookie</em></h2><p>控制台 -&gt; Application -&gt; cookies</p>
<p>cookie可以和localStorage、sessionStorage一并用作本地存储；但是cookie主业不是做本地存储，它是用来保存、记录http状态（cookie是基于session的），随着http请求和响应在客户端和服务端传递</p>
<p>http协议是无状态的，即服务器向客户端发送数据结束后，连接就会关闭，而服务器不会记录发生的一切；这就会有一个问题：如果登录后向服务器请求了一次资源，等服务器响应结束就会将连接断开，但是第二次请求一个其他的资源时，服务器已经忘记了已经登录过，所以服务器会要求重新登录，这就导致每次请求都要重新登录</p>
<blockquote>
<p>为了解决这个问题，http协议发明了cookie；<strong>严格来说cookie是http协议的一部分，既不属于客户端技术也不属于服务端技术</strong>；但是客户端和服务端都有操作cookie的相关技术。</p>
</blockquote>
<p><strong>cookie是用来保存http的状态</strong></p>
<blockquote>
<p><strong>cookie的机制/原理</strong></p>
</blockquote>
<ul>
<li>cookie是存在客户端的，但是客户端和服务端都可以操作cookie；在客户端发起请求的时候，http协议会从客户端把所有的cookie读取出来，然后带着这些cookie去请求服务器；服务器收到请求后，服务器收到的请求里面是包含cookie的，服务器就可以任意操作cookie了，服务器响应时会让http协议把cookie再带给客户端（浏览器检测到响应中有cookie，会自动把cookie保存起来）</li>
<li>以登录为例，第一次带着用户的用户名和密码去请求服务器，服务端拿到的用户名和密码去数据库中匹配，如果匹配成功就成功登录，同时服务端会在cookie中设置一个值表示登录成功；等响应的时候这个cookie就会带到客户端，浏览器会自动将它保存；等到下一次再请求时，http协议会自动带着cookie去请求</li>
</ul>
<h3 id="11-1-浏览器操作cookie"><a href="#11-1-浏览器操作cookie" class="headerlink" title="11.1 浏览器操作cookie"></a><em>11.1 浏览器操作cookie</em></h3><ol>
<li>用JS获取cookie -&gt; document.cookie 返回的是一个字符串<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie</span><br></pre></td></tr></tbody></table></figure></li>
<li>JS设置cookie -&gt; document.cookie = ‘key = value;配置属性’（一次只能写一个，多写没用）<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=eds;'</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=mars;'</span></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'age=18;'</span></span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>设置cookie时的注意事项</strong></p>
<ul>
<li>如果设置多个，就需要多次给document.cookie赋值</li>
<li>如果同名cookie，后面的会覆盖前面的；但如果同名cookie配置属性不同不能互相覆盖</li>
</ul>
<p><strong>cookie的配置属性</strong></p>
<ul>
<li>domain：可以访问这个cookie的域是哪个</li>
<li>path：可以访问这个cookie的路径是什么；一般设置为 / 表示根目录；所有根目录下面的路径都能访问这个cookie；<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=mars;path=/'</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>expires：cookie的过期时间，cookie都是有时效的，如果过期，浏览器就会删除这个cookie；expires的值是一个GMT时间<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">'name=mars;expires=Sat Jul 13 2019 16:46:45 GMT+0800'</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>删除cookie的原理：把cookie的expires设置为一个过去的时间，浏览器会自动删除</p>
</blockquote>
</li>
<li>maxAge：cookie的有效期，表示cookie在多长时间之内是有效的，如1小时、1分钟；单位是ms（服务端设置的）</li>
<li>http-only：只能给http协议使用，前端不能获取也不能修改（服务端设置）</li>
</ul>
<h2 id="12-session"><a href="#12-session" class="headerlink" title="12. session"></a><em>12. session</em></h2><p><strong>服务端技术，意为会话控制</strong></p>
<blockquote>
<p>与cookie不同，cookie是存在客户端的，而session是存在服务器上的，并且不会随着http传递；服务端技术，用来存储用户的状态及敏感信息；session-id是存在cookie中的</p>
</blockquote>
<p>cookie可以在客户端随意被更改，也可能会在传递的过程中被劫持，安全性比较低；服务器为了杜绝这种事情，服务器也创建了一个存储用户信息的东西，并且这个东西只在服务器放着，不给别人看；这个东西就是session</p>
<p><strong>session的机制/原理</strong>：</p>
<ul>
<li>以登录为例，登录时客户端会把用户名和密码发送给服务器，服务端收到请求后会去数据库中匹配，如果匹配成功，就可以登录成功了；</li>
<li>接着服务端会在cookie中设置一个表示登录状态的值，例如islogin=true；同时服务器会生成一份session文件，这个session文件有一个id，这个id叫做session-id；这个session文件中一般会存储用户的id、登录时间等信息；然后把session-id会写道cookie中；然后http协议会带着这些cookie响应给客户端</li>
<li>客户端收到响应后，会自动把响应中的cookie存储在浏览器中，这些cookie就包含了session-id</li>
<li>等再次发起请求时，http协议会带着所有的cookie去请求，服务端收到请求后从cookie中找到session-id，然后根据session-id去查找session文件；然后从session文件中获取用户的信息，如果信息有效就继续响应请求，否则认为登录失效</li>
</ul>
<h3 id="12-1-session和cookie的区别与联系"><a href="#12-1-session和cookie的区别与联系" class="headerlink" title="12.1 session和cookie的区别与联系"></a><em>12.1 session和cookie的区别与联系</em></h3><p><strong>session和cookie的区别</strong>：</p>
<ol>
<li>session是服务端技术，session存在服务器上</li>
<li>cookie是http协议的一部分，存在客户端</li>
</ol>
<p><strong>session和cookie的联系</strong>：session-id存在cookie中，会随着http通信时在客户端和服务端来回传递</p>
<h2 id="13-token"><a href="#13-token" class="headerlink" title="13. token"></a><em>13. token</em></h2><p>令牌，不是和cookie或者session一样的一种技术，而是一种用于<strong>身份校验机制</strong>；</p>
<p><strong>token的机制/原理</strong>：</p>
<ul>
<li>一般用户登录的时候，客户端会传递用户的用户名和密码给服务端，服务端匹配后，会根据用户id、登录时间等信息生成一个字符串，并且还要给这个字符串加密，甚至还需要签名（sign）</li>
<li>生成token以后会返回给客户端，下次客户端再次请求时要带着这个token来，服务器就会认识这个token，接着对token进行校验，如果通过就继续响应，如果不通过就返回错误，要求用户重新登录</li>
</ul>
<p>token常见的使用方式：</p>
<ol>
<li>把token放到cookie中，http请求时会自动带着token</li>
<li>服务端把token作为数据返回给客户端，客户端需要手动保存token；可以存在localStorage中，下次请求时要把token从localStorage中取出来，作为参数再发送给服务端</li>
<li>服务端返回token后，客户端可以把token放到请求头中，让服务端从请求头中获取<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.setRequestHeader(<span class="string">'key'</span>, <span class="string">'value'</span>) <span class="comment">// 设置请求头</span></span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>bonus：服务端中对象的一个属性就叫字段</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>需要和服务端同事沟通确定用哪种方式传递token</p>
</blockquote>
<h2 id="14-GIT"><a href="#14-GIT" class="headerlink" title="14. GIT"></a><em>14. GIT</em></h2><p><strong>git和svn</strong>：</p>
<ul>
<li>git：最流行的版本控制工具（分布式版本控制工具）<ul>
<li>git生成本地版本不需要网络，但是把本地版本同步到远程服务器时是需要网络的；git使用的是linux的命令行</li>
<li>分布式版本控制工具：git也有一个远程服务器，git的远程服务器也存储了版本库和代码；但是在成员本地也有一个版本库，生成版本时先在本地生成一个版本，然后同步到远程服务器</li>
</ul>
</li>
<li>svn：比较悠久的版本管理工具（集中式版本控制工具）<ul>
<li>svn必须通过网路把变成同步到服务器上才能生成版本，所以svn是依赖网络的，大多数情况下svn服务器部署在内网</li>
<li>集中式版本控制工具：svn有一个中央服务器，所有的版本库和成员的代码都是放在中央服务器上；svn要想生成版本，直接把修改提交到服务器上，在服务器上生成版本</li>
</ul>
</li>
</ul>
<p><strong>版本和版本库</strong>：</p>
<ul>
<li>版本：版本是修改，添加到版本库之后这个修改就成了一个版本</li>
<li>版本库：版本库记录所有的修改的库<blockquote>
<p>版本的作用：当代码出现问题的时候，可以让代码快速回退到没有问题的版本，而不用一行一行的撤销回去（回滚）；此外版本库是记录是谁修改的，什么时间修改的，修改哪里，方便对比和管理（code-review）</p>
</blockquote>
</li>
</ul>
<p><strong>git仓库</strong></p>
<ul>
<li>本地仓库：一个有.git文件夹的目录，git会收集、记录.git所在目录的所有变更，包含文件的修改、删除、新增、替换</li>
<li>远程仓库：在远程服务器上的git仓库；常见的项目托管：GitHub、coding（ <a href="https://dev.tencent.com/" target="_blank" rel="noopener">https://dev.tencent.com/</a> 用起来和GitHub一样，但coding部署在国内，速度快）、公司自己搭建的GitLab</li>
</ul>
<h3 id="14-1-GIT的使用"><a href="#14-1-GIT的使用" class="headerlink" title="14.1 GIT的使用"></a><em>14.1 GIT的使用</em></h3><p><strong>新建远程仓库</strong></p>
<ul>
<li>登录GitHub -&gt; new -&gt; 填写仓库信息 -&gt; create repository</li>
</ul>
<p><strong>将远程仓库克隆到本地</strong></p>
<ul>
<li>找到想要放这个仓库的目录，右键git bash here</li>
<li>git clone 仓库地址</li>
</ul>
<p><strong>查看当前git仓库的配置信息</strong></p>
<ul>
<li>git config –list</li>
</ul>
<p><strong>查看当前本地仓库和哪个远程仓库连接</strong></p>
<ul>
<li>git remote -v<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">origin https://github.com/edsyang/learningJS (fetch)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>git的三个区</strong></p>
<ul>
<li>工作区、暂存区、历史区（暂存区、历史区都是在版本库中，但只有历史区中的才算是版本）<ul>
<li>工作区：就是当前的仓库目录，可在这这里面做任何的修改</li>
<li>暂存区：准备生成版本的更改</li>
<li>历史区：已经成为版本的修改，只有放到历史区才能成为版本</li>
</ul>
</li>
</ul>
<p><strong>linux基本操作</strong></p>
<ul>
<li>touch 文件名.拓展名 -&gt; 新建一个文件</li>
<li>vim 文件名 -&gt; 编辑文件</li>
<li>i -&gt; 表示插入（可以向文件中插入）</li>
<li>esc -&gt; 退出编辑状态</li>
<li>:w -&gt; 保存</li>
<li>:q -&gt; 退出</li>
<li>:wq -&gt; 保存并退出</li>
<li>:q! -&gt; 强制退出</li>
</ul>
<p><strong>生成/创建一个版本</strong></p>
<ol>
<li>首先在本地的git仓库中修改一些东西（版本用来记录修改，只有先修改本地仓库中的文件，才有可能生成版本）</li>
<li>git status【查看本地仓库的状态】 - 如果文件为红色说明这些文件处于工作区；<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure></li>
<li>把工作区中变更的文件添加到暂存区  git add . / git add 文件名【当仓库中有的需要提交，有的不需要提交，就是用文件名一个一个add】<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git add 文件名</span><br></pre></td></tr></tbody></table></figure></li>
<li>添加到暂存区以后检查仓库状态；git status - 如果文件变为绿色说明文件已经添加到暂存区<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></tbody></table></figure></li>
<li>如果添加到暂存区后后悔了，执行 git rm –cached 文件名【把添加到暂存区中的文件删除】；或者使用暂存区的文件覆盖工作区的文件【这种撤销要求暂存区中有这个文件，通常用来做放弃修改当前工作区中的修改】 git checkout 文件名<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached 文件名</span><br><span class="line">git checkout 文件名</span><br></pre></td></tr></tbody></table></figure></li>
<li>把暂存区中的修改添加到历史区 git commit -m’本次提交的描述’【执行过commit之后就是把修改添加到本地版本库，还需要同步到远程仓库】<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m'本次提交的描述'</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>commit之后会形成一个版本，每个版本都有一个id（叫做版本号）</p>
</blockquote>
</li>
<li>把本地的版本库同步到远程仓库，先pull再push<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">先pull：git pull origin master</span><br><span class="line">再push：git push origin master</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>github上commits有记录着每次的修改的信息</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>git diff ：比较这次修改改了哪些东西</p>
</blockquote>
<p><strong>版本回滚（回滚到某个版本） - 下下策</strong></p>
<blockquote>
<p>不要轻易回滚！！！如果上线之后有bug，但不是很严重（不影响用户使用），紧急修复然后紧急上线</p>
</blockquote>
<ol>
<li>查看版本库中的历史记录 git log【查看所有的版本记录（提交记录）】，记录中有每次提交的版本号以及对应的注释；通过版本号（id）可以回退到任何版本<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></tbody></table></figure></li>
<li>从提交记录中找到你要回滚的版本号 git reset –hard 版本号<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 版本号</span><br></pre></td></tr></tbody></table></figure></li>
<li>回滚后，要push到远程仓库，远程仓库中的内容才会跟着回滚；回滚后push需要强推 git push origin master -f 【-f表示强制】<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master -f</span><br></pre></td></tr></tbody></table></figure>

</li>
</ol>
<h3 id="14-2-GIT分支-需要自己百度增加，有的不对"><a href="#14-2-GIT分支-需要自己百度增加，有的不对" class="headerlink" title="14.2 GIT分支  /// 需要自己百度增加，有的不对 ///"></a><em>14.2 GIT分支</em>  /// 需要自己百度增加，有的不对 ///</h3><p><strong>master分支</strong></p>
<p>在远程仓库创立时会默认创建一个master分支，这个分支叫做主干；主干分支上保存的是线上运行的代码，这些代码都是经过测试没有问题的代码</p>
<blockquote>
<p>注意：每个分支都有自己独立的版本库，如果在某个分支上的修改要保留在当前分支上，就需要把修改添加到当前分支的版本库（git add . 、git commit -m’’），如果不添加到分支的版本库，切换分支时就会带到其他的分支</p>
</blockquote>
<p><strong>基于master的开发分支</strong></p>
<p>真实项目开发中，一般不直接在master分支上开发，而是基于master新开一个开发分支；每个分支都有自己的版本库，记录发生在当前分支上的变更</p>
<blockquote>
<p>新开的分支，一般都是基于master开分支；新开的分支相当于master在开分支的那一刻master的快照（master里面的代码是什么样子，分支里面的代码就是什么样）；接下来所有的开发都是在分支上完成的；写在分支上的代码如果不合并到master，master上是不会有那些代码</p>
</blockquote>
<p><strong>合并分支</strong></p>
<p>当开发完成之后，要把分支合并到master上；因为线上跑的都是master的代码，而在分支里面开发的代码，master里面是没有的；</p>
<blockquote>
<p>但在分支合并到master之前，需要先把master上的代码同步到分支上，然后再把分支合并到master</p>
</blockquote>
<p><strong>创建一个本地分支：（创建分支前先同步master的代码）</strong></p>
<ul>
<li>git checkout -b 分支名 【创建新分支并且切换到新分支】</li>
<li>git branch 分支名 【新建分支但不会切换到新分支】</li>
</ul>
<p><strong>切换分支</strong></p>
<ul>
<li>git checkout 分支名 【从当前分支切换至某个分支】</li>
<li>git checkout - 【切换到上一次所在分支】</li>
</ul>
<p><strong>查看当前所在的分支</strong></p>
<ul>
<li>git branch -v 【带*的是当前所在分支】</li>
</ul>
<p><strong>合并分支</strong></p>
<ul>
<li>git merge 分支名 【把指定的分支名的分支合并到当前分支】</li>
</ul>
<p><strong>删除分支</strong></p>
<ul>
<li>git branch -D 分支名 </li>
</ul>
<h3 id="14-3-分支开发流程"><a href="#14-3-分支开发流程" class="headerlink" title="14.3 分支开发流程"></a><em>14.3 分支开发流程</em></h3><pre><code>1. 克隆远程仓库到本地：git clone 仓库地址

2. 在GitHub或GitLab（远程）新建一个分支，如feature_0715

3. 在本地仓库新建一个和远程分支同名的分支，如git checkout -b feature_0715

4. 同步本地分支和远程分支，如git pull origin feature_0715(分支名)

5. 在本地开发（在目录中新建、修改文件）

6. 适时的add、commit，并且要push到远程分支（防止电脑或者其他意外发生造成代码无法挽回），如git push origin feature_0715(分支名) 【如果多人协作开发，在push到远程分支之前，先pull远程分支】
注：在pull分支时有可能会引发冲突，多人修改同一个文件就会冲突；冲突后就要解决冲突，谁发现冲突谁解决；所谓解决冲突，就是确定哪些代码要哪些不要；解决冲突后需要重新commit到历史区，然后再push到远程分支

7. 重复第6步，直到功能开发完成</code></pre><h3 id="14-4-分支提测流程"><a href="#14-4-分支提测流程" class="headerlink" title="14.4 分支提测流程"></a><em>14.4 分支提测流程</em></h3><p>分支提测：开发完成后把项目交给qa的同事去测试</p>
<pre><code>1. 开发结束后，都是用分支提测

2. 一般qa会要求同步master的代码（合一下master提测），就是把master的代码合并到分支上
    2.1 本地分支切换到master
    2.2 pull master，使本地的master里面的代码和远程master同步
    2.3 切换到开发分支
    2.4 执行合并 git merge master --no-ff 【是把master合并到当前分支】
    2.5 合并master后如果有冲突，需要解决冲突（解决冲突的方式和之前是一样的）；解决完冲突再commit，然年再push到远程分支
    2.6 接着就用开发分支提测（如果没有提测文档，需要将分支名发给qa的同事）
    2.7 如果测试过程中出现bug，就在原来的开发分支上改，然后add、commit、push到远程分支上</code></pre><blockquote>
<p>所有的push之前都要pull</p>
</blockquote>
<h3 id="14-5-上线（发版）"><a href="#14-5-上线（发版）" class="headerlink" title="14.5 上线（发版）"></a><em>14.5 上线（发版）</em></h3><pre><code>1. 上线之前需要再次同步master的代码到分支（再次把master的代码合并成分支）

2. 把分支合并到master；但是一般情况下，（gitlab）都是提交merge request（MR），github上叫pull request

3. 找有权限合代码的人，帮你合并MR

4. 合完代码去找上线的人上线（一般都是运维的同事负责上线）</code></pre><h3 id="14-6-多人协作"><a href="#14-6-多人协作" class="headerlink" title="14.6 多人协作"></a><em>14.6 多人协作</em></h3><ol>
<li>如果是GitHub，把项目成员添加到项目中 Settings -&gt; Collaborators -&gt; 用GitHub名搜索，然后再邀请，被邀请的人同意后才会加入到项目中</li>
<li>如果是GitLab，leader会给你开账号，然后让他把你加到项目中就即可</li>
</ol>
<h3 id="14-7-SSH-KEY"><a href="#14-7-SSH-KEY" class="headerlink" title="14.7 SSH-KEY"></a><em>14.7 SSH-KEY</em></h3><p><strong>身份验证机制（设备）</strong></p>
<blockquote>
<p>项目中不是每次都输入密码，这样做效率很低，真实项目中使用的都是ssh-key；</p>
</blockquote>
<ul>
<li>ssh-key是建立ssh时需要的公钥；这个公钥存储在你的机器（电脑）上，通过命令行生成，生成后把这个公钥放到github或者gitlab上；</li>
<li>然后建立ssh连接时（pull和push），会自动从本地读取这个公钥，github/gitlab会比对之前存储的秘钥和本次连接携带的是否一样，如果一样就连上了，从而摆脱输入密码的困扰；</li>
</ul>
<p><strong>使用步骤SSH-KEY</strong>：</p>
<ul>
<li>生成ssh-key：进入到家目录；在git bash中输入：cd ~</li>
<li>进入家目录中的 .ssh/ 目录：cd .ssh ；如果没有可以新建：mkdir .ssh</li>
<li>执行：ssh-keygen 一路回车即可</li>
<li>cat id_rsa.pub 文件</li>
<li>复制上一步cat出来的结果</li>
<li>打开github或者gitlab，进入个人设置 settings -&gt; SSH and GPG keys -&gt; new SSHKey</li>
<li>title是对这个key的描述，把复制的key粘贴到key中，点击 Add SSH key;</li>
<li>后面再clone项目时改用SSH协议，以后所有的操作都不需要密码；<blockquote>
<p>注意SSH只对当前的设备有效，因为ssh-key是存在设备上的，换电脑就没戏了；</p>
</blockquote>
</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:1966861494@qq.com">Edsyang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://blog.lagerstroemia.com.cn/2019/07/20/course/network/11-HTTP&amp;AJAX-B.part%20two/">http://blog.lagerstroemia.com.cn/2019/07/20/course/network/11-HTTP&amp;AJAX-B.part%20two/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.lagerstroemia.com.cn" target="_blank">Edsyang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JS-Notes/">JS Notes</a></div><div class="post_share"><div class="social-share" data-image="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.png" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/07/20/course/node/12-Node.js-B.part%20two/"><img class="prev_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Node - Chapter One.B</div></div></a></div><div class="next-post pull_right"><a href="/2019/07/20/course/node/12-Node.js-A.part%20one/"><img class="next_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Node - Chapter One.A</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/17/course/read/" title="阅读指南"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-16</div><div class="relatedPosts_title">阅读指南</div></div></a></div><div class="relatedPosts_item"><a href="/2019/09/07/course/applets/applets/" title="微信小程序"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-09-07</div><div class="relatedPosts_title">微信小程序</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/course/mobile/10-Mobile Terminal-A.part one/" title="移动端 - Chapter One.A"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">移动端 - Chapter One.A</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/course/network/11-HTTP&AJAX-A.part one/" title="网络 - Chapter One.A"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">网络 - Chapter One.A</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/course/node/12-Node.js-B.part two/" title="Node - Chapter One.B"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">Node - Chapter One.B</div></div></a></div><div class="relatedPosts_item"><a href="/2019/07/20/course/node/12-Node.js-A.part one/" title="Node - Chapter One.A"><img class="relatedPosts_cover" data-src="https://tva1.sinaimg.cn/large/007S8ZIlly1gegal5ikmoj30u00xpe81.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-07-20</div><div class="relatedPosts_title">Node - Chapter One.A</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail','link'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'WgFk4Onl7sisfXpq9vHcehGJ-gzGzoHsz',
  appKey: '3DLR7iLY5al5dbIdo9kWnDHU',
  notify: false,
  verify: false,
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'en',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: true,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By Edsyang</div><div class="framework-info"><span>Driven </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="icp"><a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>冀ICP备19038398号</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/search/local-search.js"></script></body></html>